# 通用控制器需求文档 - 数据类型定义

> 版本: v3.17.5

## 0. 依赖导入

```python
# ROS 消息类型
import rospy
from std_msgs.msg import Header, Float32
from nav_msgs.msg import Odometry
from sensor_msgs.msg import Imu
from geometry_msgs.msg import TwistStamped, TransformStamped, Quaternion, PointStamped

# TF2 相关
import tf2_ros
import tf2_geometry_msgs
import tf.transformations as tft

# 标准库
from enum import IntEnum
from dataclasses import dataclass, field
from typing import Optional, List, Dict, Any, Tuple
from collections import deque
import numpy as np
import copy

# ACADOS 相关 (可选依赖，MPC 求解器)
try:
    from acados_template import AcadosOcp, AcadosOcpSolver, AcadosModel
    import casadi as ca
    ACADOS_AVAILABLE = True
except ImportError:
    ACADOS_AVAILABLE = False
```

## 1. 枚举定义

```python
from enum import IntEnum

class ControllerState(IntEnum):
    """控制器状态枚举"""
    INIT = 0
    NORMAL = 1
    SOFT_DISABLED = 2
    MPC_DEGRADED = 3
    BACKUP_ACTIVE = 4
    STOPPING = 5
    STOPPED = 6


class TrajectoryMode(IntEnum):
    """轨迹模式枚举"""
    MODE_TRACK = 0
    MODE_STOP = 1
    MODE_HOVER = 2
    MODE_EMERGENCY = 3


class TransformStatus(IntEnum):
    """坐标变换状态"""
    TF2_OK = 0
    FALLBACK_OK = 1
    FALLBACK_WARNING = 2
    FALLBACK_CRITICAL = 3
    
    def is_critical(self) -> bool:
        return self == TransformStatus.FALLBACK_CRITICAL
    
    def is_fallback(self) -> bool:
        return self != TransformStatus.TF2_OK


class HeadingMode(IntEnum):
    """全向车航向控制模式"""
    FOLLOW_VELOCITY = 0      # 朝向运动方向（默认）
    FIXED = 1                # 保持固定航向
    TARGET_POINT = 2         # 朝向目标点
    MANUAL = 3               # 外部指定航向


class PlatformType(IntEnum):
    """平台类型枚举"""
    ACKERMANN = 0
    DIFFERENTIAL = 1
    OMNI = 2
    QUADROTOR = 3
```

## 2. 基础数据类

```python
from dataclasses import dataclass, field
from typing import Optional, List, Dict, Any
import numpy as np

@dataclass
class Point3D:
    """3D 点"""
    x: float
    y: float
    z: float


@dataclass
class Twist3D:
    """3D 速度"""
    vx: float
    vy: float
    vz: float
    wz: float
```


## 3. Trajectory 数据类

```python
@dataclass
class Trajectory:
    """
    轨迹数据类
    
    说明: velocities 是世界坐标系下的速度
    """
    header: Header
    points: List[Point3D]                    # XYZ 轨迹点 (Hard Head)，世界坐标系
    velocities: Optional[np.ndarray]         # 速度数组 [N, 4]: [vx, vy, vz, wz]，世界坐标系 (Soft Head)
    dt_sec: float                            # 时间步长
    confidence: float                        # 置信度，范围 [0.0, 1.0]
    mode: TrajectoryMode = TrajectoryMode.MODE_TRACK
    soft_enabled: bool = False               # Soft 是否启用
    
    def __post_init__(self):
        """确保 confidence 在有效范围内，dt_sec 有效"""
        self.confidence = np.clip(self.confidence, 0.0, 1.0)
        if self.dt_sec <= 0:
            rospy.logwarn(f"Trajectory dt_sec={self.dt_sec} invalid, using default 0.1")
            self.dt_sec = 0.1
    
    def __len__(self) -> int:
        return len(self.points)
    
    def copy(self) -> 'Trajectory':
        """深拷贝轨迹"""
        new_header = Header()
        new_header.stamp = self.header.stamp
        new_header.frame_id = self.header.frame_id
        new_header.seq = self.header.seq
        
        if self.velocities is not None and hasattr(self.velocities, '__len__') and len(self.velocities) > 0:
            new_velocities = self.velocities.copy()
        else:
            new_velocities = None
        
        return Trajectory(
            header=new_header,
            points=[Point3D(p.x, p.y, p.z) for p in self.points],
            velocities=new_velocities,
            dt_sec=self.dt_sec,
            confidence=self.confidence,
            mode=self.mode,
            soft_enabled=self.soft_enabled
        )
    
    def get_hard_velocities(self) -> np.ndarray:
        """
        从 Hard 轨迹点计算隐含速度
        
        返回值: 世界坐标系下的速度 [N, 4]: [vx, vy, vz, wz]
        注意: 即使轨迹点不足，也返回有效数组（至少 1 行），不返回 None
        
        低速阈值说明:
        - 使用 0.05 m/s 作为低速阈值
        - 低于此速度时，航向变化率计算不稳定（arctan2 对小值敏感）
        - 此值基于典型机器人最小稳定速度选取
        """
        if len(self.points) < 2:
            return np.zeros((1, 4))
        
        velocities = []
        n = len(self.points)
        LOW_SPEED_THRESH = 0.05  # m/s，低于此速度不计算航向变化率
        
        for i in range(n - 1):
            p0, p1 = self.points[i], self.points[i + 1]
            vx = (p1.x - p0.x) / self.dt_sec
            vy = (p1.y - p0.y) / self.dt_sec
            vz = (p1.z - p0.z) / self.dt_sec
            
            # 计算航向变化率
            if i < n - 2:
                p2 = self.points[i + 2]
                vx_next = (p2.x - p1.x) / self.dt_sec
                vy_next = (p2.y - p1.y) / self.dt_sec
            elif i > 0:
                p_prev = self.points[i - 1]
                vx_prev = (p0.x - p_prev.x) / self.dt_sec
                vy_prev = (p0.y - p_prev.y) / self.dt_sec
                vx_next = 2 * vx - vx_prev
                vy_next = 2 * vy - vy_prev
            else:
                vx_next = vx
                vy_next = vy
            
            speed = np.sqrt(vx**2 + vy**2)
            speed_next = np.sqrt(vx_next**2 + vy_next**2)
            
            if speed > LOW_SPEED_THRESH and speed_next > LOW_SPEED_THRESH:
                heading_curr = np.arctan2(vy, vx)
                heading_next = np.arctan2(vy_next, vx_next)
                dheading = heading_next - heading_curr
                dheading = np.arctan2(np.sin(dheading), np.cos(dheading))
                wz = dheading / self.dt_sec
            else:
                wz = 0.0
            
            velocities.append([vx, vy, vz, wz])
        
        velocities.append(velocities[-1])
        return np.array(velocities)
    
    def get_velocities(self) -> np.ndarray:
        """
        获取速度数组（统一接口）
        
        v3.17.5 新增: 统一的速度获取方法
        
        返回值: 世界坐标系下的速度 [N, 4]: [vx, vy, vz, wz]
        
        优先级:
        1. 如果 soft_enabled 且 velocities 有效，返回 soft velocities
        2. 否则返回从 hard 轨迹点计算的速度
        
        保证: 永远返回有效的 np.ndarray，不返回 None
        """
        if self.soft_enabled and self.velocities is not None and len(self.velocities) > 0:
            return self.velocities
        return self.get_hard_velocities()
    
    def has_valid_soft_velocities(self) -> bool:
        """
        v3.17.5 新增: 检查是否有有效的 soft velocities
        """
        return (self.soft_enabled and 
                self.velocities is not None and 
                len(self.velocities) > 0)
```


## 4. 输出数据类

```python
@dataclass
class EstimatorOutput:
    """状态估计器输出"""
    state: np.ndarray               # 状态向量 [8]
    covariance: np.ndarray          # 协方差矩阵 [8x8]
    covariance_norm: float          # 协方差范数
    innovation_norm: float          # 新息范数
    imu_bias: np.ndarray            # IMU bias [3]
    slip_probability: float         # 打滑概率
    anomalies: List[str]            # 检测到的异常
    imu_available: bool = True      # IMU 可用性标志
    imu_drift_detected: bool = False  # IMU 漂移检测标志


@dataclass
class ControlOutput:
    """
    控制器输出
    
    坐标系定义:
    - 差速/阿克曼车: 机体坐标系 (vx = 前向速度, vy = 0)
    - 全向车: 世界坐标系 (vx, vy = 世界坐标系速度)
    - 无人机: 世界坐标系 (vx, vy, vz = 世界坐标系速度)
    
    frame_id 必须显式指定
    """
    vx: float                       # x 方向速度
    vy: float = 0.0                 # y 方向速度
    vz: float = 0.0                 # z 方向速度 (无人机)
    omega: float = 0.0              # 角速度 (yaw rate)
    frame_id: str = field(default_factory=lambda: "")
    success: bool = True
    solve_time_ms: float = 0.0
    health_metrics: Dict[str, Any] = field(default_factory=dict)
    
    def __post_init__(self):
        """检查 frame_id 是否已设置"""
        if not self.frame_id:
            rospy.logwarn_once("ControlOutput created without frame_id, this may cause issues")
    
    @property
    def v(self) -> float:
        """兼容旧接口：返回水平速度大小"""
        return np.sqrt(self.vx**2 + self.vy**2)
    
    @property
    def v_horizontal(self) -> float:
        """返回水平速度大小"""
        return np.sqrt(self.vx**2 + self.vy**2)
    
    @property
    def v_3d(self) -> float:
        """返回 3D 速度大小"""
        return np.sqrt(self.vx**2 + self.vy**2 + self.vz**2)
    
    def copy(self) -> 'ControlOutput':
        """v3.17 新增: 深拷贝控制输出"""
        return ControlOutput(
            vx=self.vx, vy=self.vy, vz=self.vz, omega=self.omega,
            frame_id=self.frame_id, success=self.success,
            solve_time_ms=self.solve_time_ms,
            health_metrics=self.health_metrics.copy() if self.health_metrics else {}
        )
    
    def to_twist_stamped(self, header: Header) -> TwistStamped:
        """转换为 ROS TwistStamped 消息"""
        msg = TwistStamped()
        msg.header = header
        msg.header.frame_id = self.frame_id
        msg.twist.linear.x = self.vx
        msg.twist.linear.y = self.vy
        msg.twist.linear.z = self.vz
        msg.twist.angular.z = self.omega
        return msg
```


## 5. 状态数据类

```python
@dataclass
class ConsistencyResult:
    """
    一致性检查结果
    
    data_valid 语义说明:
    - True: 所有维度的一致性计算都基于有效数据
    - False: 至少有一个维度因数据不足无法可靠计算
    
    各维度有效性条件:
    - kappa_valid: 至少 3 个轨迹点，且点间距足够大
    - v_dir_valid: 速度向量模大于阈值
    - temporal_valid: 时序窗口中至少有 2 个历史数据 (v3.17 修复)
    """
    alpha: float
    kappa_consistency: float
    v_dir_consistency: float
    temporal_smooth: float
    should_disable_soft: bool
    data_valid: bool = True


@dataclass
class SafetyDecision:
    """安全决策"""
    safe: bool
    new_state: Optional[ControllerState]
    reason: str
    limited_cmd: Optional[ControlOutput] = None


@dataclass 
class MPCHealthStatus:
    """MPC 健康状态"""
    healthy: bool
    warning: bool
    can_recover: bool
    consecutive_near_timeout: int
    kkt_residual: float
    condition_number: float


@dataclass
class TimeoutStatus:
    """超时状态"""
    odom_timeout: bool
    traj_timeout: bool
    traj_grace_exceeded: bool
    imu_timeout: bool
    last_odom_age_ms: float
    last_traj_age_ms: float
    last_imu_age_ms: float
    in_startup_grace: bool = False


@dataclass
class AttitudeCommand:
    """姿态命令"""
    roll: float
    pitch: float
    yaw: float
    thrust: float


@dataclass
class DiagnosticsV2:
    """
    诊断消息数据类
    
    对应 ROS 消息类型: controller_msgs/DiagnosticsV2
    
    注意: 实际部署时需要创建对应的 .msg 文件:
    controller_msgs/msg/DiagnosticsV2.msg
    """
    header: Header
    state: int                              # ControllerState 枚举值
    mpc_success: bool
    mpc_solve_time_ms: float
    backup_active: bool
    
    # MPC 健康状态
    mpc_health_kkt_residual: float
    mpc_health_condition_number: float
    mpc_health_consecutive_near_timeout: int
    mpc_health_degradation_warning: bool
    mpc_health_can_recover: bool
    
    # 一致性指标
    consistency_curvature: float
    consistency_velocity_dir: float
    consistency_temporal: float
    consistency_alpha_soft: float
    consistency_data_valid: bool
    
    # 状态估计器健康
    estimator_covariance_norm: float
    estimator_innovation_norm: float
    estimator_slip_probability: float
    estimator_imu_drift_detected: bool
    estimator_imu_bias: np.ndarray          # [3]
    estimator_imu_available: bool
    
    # 跟踪误差
    tracking_lateral_error: float
    tracking_longitudinal_error: float
    tracking_heading_error: float
    tracking_prediction_error: float
    
    # 坐标变换状态
    transform_tf2_available: bool
    transform_fallback_duration_ms: float
    transform_accumulated_drift: float
    
    # 超时状态
    timeout_odom: bool
    timeout_traj: bool
    timeout_traj_grace_exceeded: bool
    timeout_imu: bool
    timeout_last_odom_age_ms: float
    timeout_last_traj_age_ms: float
    timeout_last_imu_age_ms: float
    timeout_in_startup_grace: bool
    
    # 控制命令
    cmd_vx: float
    cmd_vy: float
    cmd_vz: float
    cmd_omega: float
    cmd_frame_id: str
    
    # 过渡进度
    transition_progress: float
    
    def to_ros_msg(self) -> Dict[str, Any]:
        """转换为 ROS 消息格式的字典"""
        return {
            'header': self.header,
            'state': self.state,
            'mpc_success': self.mpc_success,
            'mpc_solve_time_ms': self.mpc_solve_time_ms,
            'backup_active': self.backup_active,
            'mpc_health': {
                'kkt_residual': self.mpc_health_kkt_residual,
                'condition_number': self.mpc_health_condition_number,
                'consecutive_near_timeout': self.mpc_health_consecutive_near_timeout,
                'degradation_warning': self.mpc_health_degradation_warning,
                'can_recover': self.mpc_health_can_recover
            },
            'consistency': {
                'curvature': self.consistency_curvature,
                'velocity_dir': self.consistency_velocity_dir,
                'temporal': self.consistency_temporal,
                'alpha_soft': self.consistency_alpha_soft,
                'data_valid': self.consistency_data_valid
            },
            'estimator_health': {
                'covariance_norm': self.estimator_covariance_norm,
                'innovation_norm': self.estimator_innovation_norm,
                'slip_probability': self.estimator_slip_probability,
                'imu_drift_detected': self.estimator_imu_drift_detected,
                'imu_bias': list(self.estimator_imu_bias),
                'imu_available': self.estimator_imu_available
            },
            'tracking': {
                'lateral_error': self.tracking_lateral_error,
                'longitudinal_error': self.tracking_longitudinal_error,
                'heading_error': self.tracking_heading_error,
                'prediction_error': self.tracking_prediction_error
            },
            'transform': {
                'tf2_available': self.transform_tf2_available,
                'fallback_duration_ms': self.transform_fallback_duration_ms,
                'accumulated_drift': self.transform_accumulated_drift
            },
            'timeout': {
                'odom_timeout': self.timeout_odom,
                'traj_timeout': self.timeout_traj,
                'traj_grace_exceeded': self.timeout_traj_grace_exceeded,
                'imu_timeout': self.timeout_imu,
                'last_odom_age_ms': self.timeout_last_odom_age_ms,
                'last_traj_age_ms': self.timeout_last_traj_age_ms,
                'last_imu_age_ms': self.timeout_last_imu_age_ms,
                'in_startup_grace': self.timeout_in_startup_grace
            },
            'cmd': {
                'vx': self.cmd_vx,
                'vy': self.cmd_vy,
                'vz': self.cmd_vz,
                'omega': self.cmd_omega,
                'frame_id': self.cmd_frame_id
            },
            'transition_progress': self.transition_progress
        }
```


## 6. 接口定义

```python
from abc import ABC, abstractmethod

class IStateEstimator(ABC):
    """状态估计器接口"""
    
    @abstractmethod
    def predict(self, dt: float) -> None:
        pass
    
    @abstractmethod
    def update_odom(self, odom: Odometry) -> None:
        pass
    
    @abstractmethod
    def update_imu(self, imu: Imu) -> None:
        pass
    
    @abstractmethod
    def get_state(self) -> EstimatorOutput:
        pass
    
    @abstractmethod
    def reset(self) -> None:
        pass
    
    @abstractmethod
    def set_imu_available(self, available: bool) -> None:
        pass
    
    @abstractmethod
    def apply_drift_correction(self, dx: float, dy: float, dtheta: float) -> None:
        """应用外部漂移校正"""
        pass


class ITrajectoryTracker(ABC):
    """轨迹跟踪器接口"""
    
    @abstractmethod
    def compute(self, state: np.ndarray, trajectory: Trajectory, 
                consistency: ConsistencyResult) -> ControlOutput:
        pass
    
    @abstractmethod
    def get_health_metrics(self) -> Dict[str, Any]:
        pass
    
    @abstractmethod
    def set_horizon(self, horizon: int) -> None:
        pass
    
    @abstractmethod
    def shutdown(self) -> None:
        """资源清理，所有实现必须提供"""
        pass


class IConsistencyChecker(ABC):
    """一致性检查器接口"""
    
    @abstractmethod
    def compute(self, trajectory: Trajectory) -> ConsistencyResult:
        pass
    
    @abstractmethod
    def reset(self) -> None:
        pass


class ISafetyMonitor(ABC):
    """安全监控器接口"""
    
    @abstractmethod
    def check(self, state: np.ndarray, cmd: ControlOutput, 
              diagnostics: Dict[str, Any]) -> SafetyDecision:
        pass
    
    @abstractmethod
    def reset(self) -> None:
        pass


class ISmoothTransition(ABC):
    """平滑过渡接口"""
    
    @abstractmethod
    def start_transition(self, from_cmd: ControlOutput) -> None:
        pass
    
    @abstractmethod
    def get_blended_output(self, new_cmd: ControlOutput, 
                          current_time: rospy.Time) -> ControlOutput:
        pass
    
    @abstractmethod
    def is_complete(self) -> bool:
        pass
    
    @abstractmethod
    def get_progress(self) -> float:
        pass


class ICoordinateTransformer(ABC):
    """坐标变换器接口"""
    
    @abstractmethod
    def transform_trajectory(self, traj: Trajectory, target_frame: str, 
                            target_time: rospy.Time) -> Tuple[Trajectory, TransformStatus]:
        pass
    
    @abstractmethod
    def get_status(self) -> Dict[str, Any]:
        pass
    
    @abstractmethod
    def set_state_estimator(self, estimator: IStateEstimator) -> None:
        pass
```
