# 通用控制器需求文档 - 控制器实现

> 版本: v3.17.4
>
> v3.17.4 修复:
> - `MPCController._solve_with_acados()`: 在循环外初始化 `theta_ref`，修复当 `i>0` 且所有条件分支都不满足时变量未定义的问题
>
> v3.17.3 修复:
> - `MPCController.set_horizon()`: 添加求解器重新初始化逻辑，使 horizon 动态调整生效
>
> v3.17.2 修复:
> - `MPCController._solve_with_acados()`: 使用轨迹的 wz 字段计算参考航向，提升航向跟踪平滑性
>
> v3.17.1 修复:
> - `RobustCoordinateTransformer._handle_fallback()`: 实现基于 odom 积分的轨迹变换，不再返回原始轨迹
> - `MPCController`: 添加完整的 ACADOS 集成框架和 `_solve_with_acados()` 方法

## 1. 平滑过渡控制器

### 1.1 指数平滑过渡

```python
class ExponentialSmoothTransition(ISmoothTransition):
    """指数平滑过渡"""
    
    def __init__(self, config: Dict[str, Any]):
        self.tau = config.get('tau', 0.1)
        self.max_duration = config.get('max_duration', 0.5)
        self.completion_threshold = config.get('completion_threshold', 0.95)
        self.start_time: Optional[rospy.Time] = None
        self.in_transition = False
        self.from_cmd: Optional[ControlOutput] = None
        self.progress = 0.0
    
    def start_transition(self, from_cmd: ControlOutput) -> None:
        self.start_time = rospy.Time.now()
        self.in_transition = True
        self.from_cmd = from_cmd.copy()  # v3.17: 使用 copy() 方法
        self.progress = 0.0
    
    def get_blended_output(self, new_cmd: ControlOutput, 
                          current_time: rospy.Time) -> ControlOutput:
        if not self.in_transition or self.from_cmd is None:
            return new_cmd
        
        elapsed = (current_time - self.start_time).to_sec()
        alpha = 1.0 - np.exp(-elapsed / self.tau)
        self.progress = alpha
        
        blended_vx = self.from_cmd.vx * (1 - alpha) + new_cmd.vx * alpha
        blended_vy = self.from_cmd.vy * (1 - alpha) + new_cmd.vy * alpha
        blended_vz = self.from_cmd.vz * (1 - alpha) + new_cmd.vz * alpha
        blended_omega = self.from_cmd.omega * (1 - alpha) + new_cmd.omega * alpha
        
        if alpha >= self.completion_threshold or elapsed > self.max_duration:
            self.in_transition = False
            self.from_cmd = None
            return new_cmd
        
        return ControlOutput(
            vx=blended_vx, vy=blended_vy, vz=blended_vz, omega=blended_omega,
            frame_id=new_cmd.frame_id, success=new_cmd.success,
            solve_time_ms=new_cmd.solve_time_ms,
            health_metrics={'transition_progress': alpha}
        )
    
    def is_complete(self) -> bool:
        return not self.in_transition
    
    def get_progress(self) -> float:
        return self.progress
```

### 1.2 线性平滑过渡

```python
class LinearSmoothTransition(ISmoothTransition):
    """线性平滑过渡"""
    
    def __init__(self, config: Dict[str, Any]):
        self.duration = config.get('duration', 0.2)
        self.start_time: Optional[rospy.Time] = None
        self.in_transition = False
        self.from_cmd: Optional[ControlOutput] = None
        self.progress = 0.0
    
    def start_transition(self, from_cmd: ControlOutput) -> None:
        self.start_time = rospy.Time.now()
        self.in_transition = True
        self.from_cmd = from_cmd.copy()  # v3.17: 使用 copy() 方法
        self.progress = 0.0
    
    def get_blended_output(self, new_cmd: ControlOutput, 
                          current_time: rospy.Time) -> ControlOutput:
        if not self.in_transition or self.from_cmd is None or self.start_time is None:
            return new_cmd
        
        elapsed = (current_time - self.start_time).to_sec()
        alpha = min(elapsed / self.duration, 1.0)
        self.progress = alpha
        
        blended_vx = self.from_cmd.vx * (1 - alpha) + new_cmd.vx * alpha
        blended_vy = self.from_cmd.vy * (1 - alpha) + new_cmd.vy * alpha
        blended_vz = self.from_cmd.vz * (1 - alpha) + new_cmd.vz * alpha
        blended_omega = self.from_cmd.omega * (1 - alpha) + new_cmd.omega * alpha
        
        if alpha >= 1.0:
            self.in_transition = False
            self.from_cmd = None
            return new_cmd
        
        return ControlOutput(
            vx=blended_vx, vy=blended_vy, vz=blended_vz, omega=blended_omega,
            frame_id=new_cmd.frame_id, success=new_cmd.success,
            solve_time_ms=new_cmd.solve_time_ms,
            health_metrics={'transition_progress': alpha}
        )
    
    def is_complete(self) -> bool:
        return not self.in_transition
    
    def get_progress(self) -> float:
        return self.progress
```


## 2. 坐标变换器

```python
class RobustCoordinateTransformer(ICoordinateTransformer):
    """
    带降级时限和恢复校正的坐标变换器
    
    漂移校正逻辑:
    - 漂移 = TF2 变换 - odom 积分变换
    - 记录 fallback 开始时的 TF2 变换和状态估计器位置
    - TF2 恢复时，比较当前 TF2 变换与 fallback 期间的 odom 积分
    - 差值即为需要校正的漂移
    """
    
    def __init__(self, config: Dict[str, Any]):
        self.tf_buffer = tf2_ros.Buffer()
        self.tf_listener = tf2_ros.TransformListener(self.tf_buffer)
        self.fallback_duration_limit = config['fallback_duration_limit_ms'] / 1000.0
        self.fallback_critical_limit = config.get('fallback_critical_limit_ms', 1000) / 1000.0
        self.tf2_timeout = config['tf2_timeout_ms'] / 1000.0
        self.drift_estimation_enabled = config['drift_estimation_enabled']
        self.recovery_correction_enabled = config['recovery_correction_enabled']
        self.drift_rate = config.get('drift_rate', 0.01)
        
        self.fallback_start_time: Optional[rospy.Time] = None
        self.accumulated_drift = 0.0
        self.state_estimator: Optional[IStateEstimator] = None
        
        # 用于漂移校正的状态记录
        self._last_tf2_transform: Optional[TransformStamped] = None
        self._fallback_start_tf2_position: Optional[np.ndarray] = None
        self._fallback_start_tf2_yaw: float = 0.0
        self._fallback_start_estimator_position: Optional[np.ndarray] = None
        self._fallback_start_estimator_theta: float = 0.0
    
    def transform_trajectory(self, traj: Trajectory, target_frame: str, 
                            target_time: rospy.Time) -> Tuple[Trajectory, TransformStatus]:
        try:
            transform = self.tf_buffer.lookup_transform(
                target_frame, traj.header.frame_id, target_time,
                timeout=rospy.Duration(self.tf2_timeout)
            )
            
            # TF2 恢复时执行漂移校正
            if self.fallback_start_time is not None:
                if self.recovery_correction_enabled:
                    self._apply_recovery_correction(transform)
                self.fallback_start_time = None
                self.accumulated_drift = 0.0
            
            self._last_tf2_transform = transform
            self._last_status = TransformStatus.TF2_OK
            return self._apply_transform(traj, transform, target_frame), TransformStatus.TF2_OK
        
        except (tf2_ros.LookupException, tf2_ros.ExtrapolationException):
            return self._handle_fallback(traj, target_time, target_frame)
    
    def _apply_transform(self, traj: Trajectory, transform: TransformStamped, 
                        target_frame: str) -> Trajectory:
        """应用坐标变换到轨迹"""
        transformed_points = []
        for p in traj.points:
            # 创建 PointStamped 并变换
            point_stamped = tf2_geometry_msgs.PointStamped()
            point_stamped.header = traj.header
            point_stamped.point.x = p.x
            point_stamped.point.y = p.y
            point_stamped.point.z = p.z
            
            # 应用变换
            tx = transform.transform.translation.x
            ty = transform.transform.translation.y
            tz = transform.transform.translation.z
            
            q = transform.transform.rotation
            _, _, yaw = tft.euler_from_quaternion([q.x, q.y, q.z, q.w])
            
            cos_yaw = np.cos(yaw)
            sin_yaw = np.sin(yaw)
            
            new_x = p.x * cos_yaw - p.y * sin_yaw + tx
            new_y = p.x * sin_yaw + p.y * cos_yaw + ty
            new_z = p.z + tz
            
            transformed_points.append(Point3D(new_x, new_y, new_z))
        
        new_traj = traj.copy()
        new_traj.points = transformed_points
        new_traj.header.frame_id = target_frame
        return new_traj
    
    def _handle_fallback(self, traj: Trajectory, target_time: rospy.Time,
                        target_frame: str) -> Tuple[Trajectory, TransformStatus]:
        """
        处理 TF2 不可用时的降级
        
        v3.17 修复: 使用 odom 积分计算变换，而不是返回原始轨迹
        
        降级变换逻辑:
        1. 记录 fallback 开始时的最后一次有效 TF2 变换和状态估计器位置
        2. 计算 fallback 期间状态估计器的位移增量
        3. 将位移增量叠加到最后一次 TF2 变换上，得到估计的当前变换
        4. 应用估计变换到轨迹
        """
        current_time = rospy.Time.now()
        
        if self.fallback_start_time is None:
            self.fallback_start_time = current_time
            # 记录 fallback 开始时的状态
            if self._last_tf2_transform is not None and self.state_estimator is not None:
                state = self.state_estimator.get_state()
                self._fallback_start_estimator_position = state.state[:3].copy()
                self._fallback_start_estimator_theta = state.state[6]
                t = self._last_tf2_transform.transform.translation
                self._fallback_start_tf2_position = np.array([t.x, t.y, t.z])
                q = self._last_tf2_transform.transform.rotation
                _, _, self._fallback_start_tf2_yaw = tft.euler_from_quaternion([q.x, q.y, q.z, q.w])
        
        fallback_duration = (current_time - self.fallback_start_time).to_sec()
        
        # 累积漂移估计
        if self.drift_estimation_enabled:
            self.accumulated_drift += self.drift_rate * (1.0 / 50.0)  # 假设 50Hz
        
        # 确定降级状态
        if fallback_duration > self.fallback_critical_limit:
            status = TransformStatus.FALLBACK_CRITICAL
        elif fallback_duration > self.fallback_duration_limit:
            status = TransformStatus.FALLBACK_WARNING
        else:
            status = TransformStatus.FALLBACK_OK
        
        self._last_status = status
        
        # 使用 odom 积分计算变换并应用到轨迹
        if (self.state_estimator is not None and 
            self._last_tf2_transform is not None and
            self._fallback_start_estimator_position is not None and
            self._fallback_start_tf2_position is not None):
            
            # 获取当前状态估计
            state = self.state_estimator.get_state()
            current_estimator_position = state.state[:3]
            current_estimator_theta = state.state[6]
            
            # 计算 fallback 期间的位移增量 (odom 积分)
            delta_position = current_estimator_position - self._fallback_start_estimator_position
            delta_theta = current_estimator_theta - self._fallback_start_estimator_theta
            delta_theta = np.arctan2(np.sin(delta_theta), np.cos(delta_theta))  # 归一化
            
            # 估计当前变换 = 最后 TF2 变换 + odom 位移增量
            estimated_tx = self._fallback_start_tf2_position[0] + delta_position[0]
            estimated_ty = self._fallback_start_tf2_position[1] + delta_position[1]
            estimated_tz = self._fallback_start_tf2_position[2] + delta_position[2]
            estimated_yaw = self._fallback_start_tf2_yaw + delta_theta
            
            # 应用估计变换到轨迹
            transformed_traj = self._apply_estimated_transform(
                traj, estimated_tx, estimated_ty, estimated_tz, estimated_yaw, target_frame)
            
            return transformed_traj, status
        
        # 如果没有足够信息进行变换，返回原始轨迹
        rospy.logwarn_throttle(1.0, "TF2 fallback: insufficient data for odom-based transform")
        return traj, status
    
    def _apply_estimated_transform(self, traj: Trajectory, tx: float, ty: float, 
                                   tz: float, yaw: float, target_frame: str) -> Trajectory:
        """
        应用估计的变换到轨迹
        
        v3.17 新增: 用于 TF2 fallback 时的轨迹变换
        """
        cos_yaw = np.cos(yaw)
        sin_yaw = np.sin(yaw)
        
        transformed_points = []
        for p in traj.points:
            new_x = p.x * cos_yaw - p.y * sin_yaw + tx
            new_y = p.x * sin_yaw + p.y * cos_yaw + ty
            new_z = p.z + tz
            transformed_points.append(Point3D(new_x, new_y, new_z))
        
        new_traj = traj.copy()
        new_traj.points = transformed_points
        new_traj.header.frame_id = target_frame
        return new_traj
    
    def _apply_recovery_correction(self, current_transform: TransformStamped) -> None:
        """计算并应用漂移校正"""
        if self.state_estimator is None:
            return
        
        if self._fallback_start_tf2_position is None or self._fallback_start_estimator_position is None:
            return
        
        # 获取当前 TF2 位置
        t = current_transform.transform.translation
        current_tf2_position = np.array([t.x, t.y, t.z])
        
        # 获取当前状态估计位置
        state = self.state_estimator.get_state()
        current_estimator_position = state.state[:3]
        
        # 计算 TF2 期间的位移
        tf2_displacement = current_tf2_position - self._fallback_start_tf2_position
        
        # 计算 odom 积分期间的位移
        odom_displacement = current_estimator_position - self._fallback_start_estimator_position
        
        # 漂移 = TF2 位移 - odom 位移
        drift_x = tf2_displacement[0] - odom_displacement[0]
        drift_y = tf2_displacement[1] - odom_displacement[1]
        
        # 计算航向漂移（简化：使用位移方向差异）
        drift_theta = 0.0  # 可以通过更复杂的方法估计
        
        drift_magnitude = np.sqrt(drift_x**2 + drift_y**2)
        
        if drift_magnitude > 0.02:  # 只有漂移超过 2cm 才校正
            self.state_estimator.apply_drift_correction(drift_x, drift_y, drift_theta)
            rospy.loginfo(f"Applied drift correction: dx={drift_x:.3f}, dy={drift_y:.3f}")
        
        # 清理状态
        self._fallback_start_tf2_position = None
        self._fallback_start_estimator_position = None
    
    def set_state_estimator(self, estimator: IStateEstimator) -> None:
        """设置状态估计器引用"""
        self.state_estimator = estimator
    
    def get_status(self) -> Dict[str, Any]:
        fallback_duration_ms = 0.0
        if self.fallback_start_time is not None:
            fallback_duration_ms = (rospy.Time.now() - self.fallback_start_time).to_sec() * 1000
        
        return {
            'tf2_available': self.fallback_start_time is None,
            'fallback_duration_ms': fallback_duration_ms,
            'accumulated_drift': self.accumulated_drift,
            'is_critical': self._last_status.is_critical() if hasattr(self, '_last_status') else False
        }
```


## 3. Pure Pursuit 备用控制器

```python
class PurePursuitController(ITrajectoryTracker):
    """Pure Pursuit 备用控制器"""
    
    def __init__(self, config: Dict[str, Any], platform_config: Dict[str, Any]):
        self.lookahead_dist = config['lookahead_dist']
        self.min_lookahead = config['min_lookahead']
        self.max_lookahead = config['max_lookahead']
        self.lookahead_ratio = config['lookahead_ratio']
        self.kp_z = config.get('kp_z', 1.0)
        self.dt = config.get('dt', 0.02)
        
        constraints = platform_config.get('constraints', {})
        self.v_max = constraints.get('v_max', 2.0)
        self.v_min = constraints.get('v_min', 0.0)
        self.omega_max = constraints.get('omega_max', 2.0)
        self.omega_max_low = constraints.get('omega_max_low', 1.0)
        self.v_low_thresh = constraints.get('v_low_thresh', 0.1)
        self.a_max = constraints.get('a_max', 1.5)
        self.az_max = constraints.get('az_max', 1.0)
        self.alpha_max = constraints.get('alpha_max', 3.0)
        self.vz_max = constraints.get('vz_max', 2.0)
        
        # 全向车约束
        self.vx_max = constraints.get('vx_max', self.v_max)
        self.vx_min = constraints.get('vx_min', -self.v_max)
        self.vy_max = constraints.get('vy_max', self.v_max)
        self.vy_min = constraints.get('vy_min', -self.v_max)
        
        self.output_type = platform_config.get('output_type', 'differential')
        self.output_frame = platform_config.get('output_frame', 'base_link')
        self.platform_type = platform_config.get('type', PlatformType.DIFFERENTIAL)
        self.is_3d = self.platform_type == PlatformType.QUADROTOR
        self.is_omni = self.platform_type == PlatformType.OMNI
        
        # 航向控制
        self.heading_mode = self._parse_heading_mode(config.get('heading_mode', 'follow_velocity'))
        self.kp_heading = config.get('kp_heading', 1.5)
        self.fixed_heading: Optional[float] = config.get('fixed_heading')
        
        self.last_cmd: Optional[ControlOutput] = None
        self._horizon: int = 20
        self._current_position: Optional[np.ndarray] = None
        
        self._manual_heading: Optional[float] = None
        self._manual_heading_sub: Optional[rospy.Subscriber] = None
        self._is_shutdown = False
        
        if self.heading_mode == HeadingMode.MANUAL:
            self._manual_heading_sub = rospy.Subscriber(
                '/cmd/heading', Float32, self._manual_heading_callback
            )
    
    def _parse_heading_mode(self, mode_str: str) -> HeadingMode:
        mode_map = {
            'follow_velocity': HeadingMode.FOLLOW_VELOCITY,
            'fixed': HeadingMode.FIXED,
            'target_point': HeadingMode.TARGET_POINT,
            'manual': HeadingMode.MANUAL
        }
        return mode_map.get(mode_str.lower(), HeadingMode.FOLLOW_VELOCITY)
    
    def _manual_heading_callback(self, msg: Float32) -> None:
        if not self._is_shutdown:
            self._manual_heading = msg.data
    
    def set_manual_heading(self, heading: float) -> None:
        self._manual_heading = heading
    
    def shutdown(self) -> None:
        """资源清理"""
        self._is_shutdown = True
        if self._manual_heading_sub is not None:
            self._manual_heading_sub.unregister()
            self._manual_heading_sub = None
    
    def compute(self, state: np.ndarray, trajectory: Trajectory, 
                consistency: ConsistencyResult) -> ControlOutput:
        if len(trajectory.points) < 2:
            return self._smooth_stop_command()
        
        px, py, pz = state[0], state[1], state[2]
        current_v = np.sqrt(state[3]**2 + state[4]**2)
        theta = state[6]
        
        self._current_position = np.array([px, py, pz])
        
        # 计算前视点
        lookahead = self._compute_lookahead(current_v)
        lookahead_point, target_idx = self._find_lookahead_point(
            trajectory.points, px, py, lookahead)
        
        if lookahead_point is None:
            return self._smooth_stop_command()
        
        # 根据平台类型计算输出
        dx = lookahead_point.x - px
        dy = lookahead_point.y - py
        dist_to_target = np.sqrt(dx**2 + dy**2)
        target_v = self._compute_target_velocity(trajectory, target_idx)
        
        vz = 0.0
        if self.is_3d and target_idx < len(trajectory.points):
            target_z = trajectory.points[target_idx].z
            vz = self.kp_z * (target_z - pz)
            vz = np.clip(vz, -self.vz_max, self.vz_max)
        
        omega_limit = self._get_omega_limit(current_v)
        
        if self.output_type == 'differential':
            cmd = self._compute_differential_output(dx, dy, theta, target_v, dist_to_target, omega_limit)
        elif self.output_type == 'omni':
            cmd = self._compute_omni_output(dx, dy, theta, target_v, dist_to_target, trajectory, target_idx, omega_limit)
        else:
            cmd = self._compute_3d_output(dx, dy, theta, target_v, dist_to_target, vz, trajectory, target_idx, omega_limit)
        
        # 应用速度平滑
        cmd = self._apply_velocity_smoothing(cmd)
        
        # 应用全向车约束
        if self.is_omni:
            cmd = self._apply_omni_constraints(cmd)
        
        self.last_cmd = cmd
        return cmd
    
    def get_health_metrics(self) -> Dict[str, Any]:
        return {'type': 'pure_pursuit', 'active': True}
    
    def set_horizon(self, horizon: int) -> None:
        self._horizon = horizon
    
    def _get_omega_limit(self, current_v: float) -> float:
        if current_v < self.v_low_thresh:
            return self.omega_max_low
        return self.omega_max
    
    def _compute_differential_output(self, dx: float, dy: float, theta: float,
                                     target_v: float, dist_to_target: float,
                                     omega_limit: float) -> ControlOutput:
        local_x = dx * np.cos(theta) + dy * np.sin(theta)
        local_y = -dx * np.sin(theta) + dy * np.cos(theta)
        
        L_sq = local_x**2 + local_y**2
        curvature = 2.0 * local_y / L_sq if L_sq > 1e-6 else 0.0
        
        if abs(curvature) > 0.1:
            v_curvature = min(omega_limit / abs(curvature), self.v_max)
            target_v = min(target_v, v_curvature)
        
        omega = target_v * curvature
        omega = np.clip(omega, -omega_limit, omega_limit)
        
        return ControlOutput(vx=target_v, vy=0.0, vz=0.0, omega=omega, 
                            frame_id="base_link", success=True)
    
    def _compute_omni_output(self, dx: float, dy: float, theta: float,
                            target_v: float, dist_to_target: float,
                            trajectory: Trajectory, target_idx: int,
                            omega_limit: float) -> ControlOutput:
        if dist_to_target > 1e-6:
            vx_world = target_v * dx / dist_to_target
            vy_world = target_v * dy / dist_to_target
        else:
            vx_world = 0.0
            vy_world = 0.0
        
        omega = self._compute_heading_control(dx, dy, theta, dist_to_target, trajectory, target_idx, omega_limit)
        
        return ControlOutput(vx=vx_world, vy=vy_world, vz=0.0, omega=omega,
                            frame_id="world", success=True)
    
    def _compute_3d_output(self, dx: float, dy: float, theta: float,
                          target_v: float, dist_to_target: float, vz: float,
                          trajectory: Trajectory, target_idx: int,
                          omega_limit: float) -> ControlOutput:
        if dist_to_target > 1e-6:
            vx_world = target_v * dx / dist_to_target
            vy_world = target_v * dy / dist_to_target
        else:
            vx_world = 0.0
            vy_world = 0.0
        
        omega = self._compute_heading_control(dx, dy, theta, dist_to_target, trajectory, target_idx, omega_limit)
        
        return ControlOutput(vx=vx_world, vy=vy_world, vz=vz, omega=omega,
                            frame_id="world", success=True)
    
    def _compute_heading_control(self, dx: float, dy: float, theta: float,
                                 dist_to_target: float, trajectory: Trajectory,
                                 target_idx: int, omega_limit: float) -> float:
        if self.heading_mode == HeadingMode.FOLLOW_VELOCITY:
            if dist_to_target > 0.1:
                target_heading = np.arctan2(dy, dx)
                heading_error = np.arctan2(np.sin(target_heading - theta), np.cos(target_heading - theta))
                omega = self.kp_heading * heading_error
            else:
                omega = 0.0
        elif self.heading_mode == HeadingMode.FIXED:
            if self.fixed_heading is not None:
                heading_error = np.arctan2(np.sin(self.fixed_heading - theta), np.cos(self.fixed_heading - theta))
                omega = self.kp_heading * heading_error
            else:
                omega = 0.0
        elif self.heading_mode == HeadingMode.TARGET_POINT:
            if len(trajectory.points) > 0 and self._current_position is not None:
                end_point = trajectory.points[-1]
                px, py = self._current_position[0], self._current_position[1]
                target_heading = np.arctan2(end_point.y - py, end_point.x - px)
                heading_error = np.arctan2(np.sin(target_heading - theta), np.cos(target_heading - theta))
                omega = self.kp_heading * heading_error
            else:
                omega = 0.0
        elif self.heading_mode == HeadingMode.MANUAL:
            if self._manual_heading is not None:
                heading_error = np.arctan2(np.sin(self._manual_heading - theta), 
                                          np.cos(self._manual_heading - theta))
                omega = self.kp_heading * heading_error
            else:
                omega = 0.0
                rospy.logwarn_throttle(5.0, "HeadingMode.MANUAL but no manual heading received")
        else:
            omega = 0.0
        
        return np.clip(omega, -omega_limit, omega_limit)
    
    def _apply_velocity_smoothing(self, cmd: ControlOutput) -> ControlOutput:
        if self.last_cmd is None:
            return cmd
        
        max_dv = self.a_max * self.dt
        max_dvz = self.az_max * self.dt
        max_domega = self.alpha_max * self.dt
        
        smoothed_vx = np.clip(cmd.vx, self.last_cmd.vx - max_dv, self.last_cmd.vx + max_dv)
        smoothed_vy = np.clip(cmd.vy, self.last_cmd.vy - max_dv, self.last_cmd.vy + max_dv)
        smoothed_vz = np.clip(cmd.vz, self.last_cmd.vz - max_dvz, self.last_cmd.vz + max_dvz)
        smoothed_omega = np.clip(cmd.omega, self.last_cmd.omega - max_domega, self.last_cmd.omega + max_domega)
        
        return ControlOutput(vx=smoothed_vx, vy=smoothed_vy, vz=smoothed_vz, omega=smoothed_omega,
                            frame_id=cmd.frame_id, success=cmd.success)
    
    def _smooth_stop_command(self) -> ControlOutput:
        if self.last_cmd is None:
            return ControlOutput(vx=0.0, vy=0.0, vz=0.0, omega=0.0, frame_id=self.output_frame, success=True)
        
        max_dv = self.a_max * self.dt
        max_dvz = self.az_max * self.dt
        max_domega = self.alpha_max * self.dt
        
        def smooth_to_zero(value: float, max_change: float) -> float:
            if abs(value) <= max_change:
                return 0.0
            return value - max_change if value > 0 else value + max_change
        
        cmd = ControlOutput(
            vx=smooth_to_zero(self.last_cmd.vx, max_dv),
            vy=smooth_to_zero(self.last_cmd.vy, max_dv),
            vz=smooth_to_zero(self.last_cmd.vz, max_dvz),
            omega=smooth_to_zero(self.last_cmd.omega, max_domega),
            frame_id=self.output_frame, success=True
        )
        self.last_cmd = cmd
        return cmd
    
    def _compute_lookahead(self, current_v: float) -> float:
        lookahead = self.lookahead_dist + self.lookahead_ratio * current_v
        return np.clip(lookahead, self.min_lookahead, self.max_lookahead)
    
    def _find_lookahead_point(self, points: List[Point3D], px: float, py: float, 
                              lookahead: float) -> Tuple[Optional[Point3D], int]:
        min_dist = float('inf')
        closest_idx = 0
        for i, p in enumerate(points):
            dist = np.sqrt((p.x - px)**2 + (p.y - py)**2)
            if dist < min_dist:
                min_dist = dist
                closest_idx = i
        
        for i in range(closest_idx, len(points)):
            p = points[i]
            dist = np.sqrt((p.x - px)**2 + (p.y - py)**2)
            if dist >= lookahead:
                return p, i
        
        if len(points) > 0:
            return points[-1], len(points) - 1
        return None, 0
    
    def _compute_target_velocity(self, trajectory: Trajectory, target_idx: int) -> float:
        if trajectory.soft_enabled and trajectory.velocities is not None:
            if target_idx < len(trajectory.velocities):
                v_soft = np.linalg.norm(trajectory.velocities[target_idx, :2])
                target_v = min(v_soft, self.v_max)
            else:
                target_v = self.v_max * 0.5
        else:
            target_v = self.v_max * 0.5
        
        v_min_forward = max(0.0, self.v_min)
        return np.clip(target_v, v_min_forward, self.v_max)
    
    def _apply_omni_constraints(self, cmd: ControlOutput) -> ControlOutput:
        constrained_vx = np.clip(cmd.vx, self.vx_min, self.vx_max)
        constrained_vy = np.clip(cmd.vy, self.vy_min, self.vy_max)
        
        return ControlOutput(
            vx=constrained_vx, vy=constrained_vy, vz=cmd.vz, omega=cmd.omega,
            frame_id=cmd.frame_id, success=cmd.success,
            health_metrics=cmd.health_metrics.copy() if cmd.health_metrics else {}
        )
```


## 4. MPC 控制器 (v3.17 完善 ACADOS 集成框架)

```python
class MPCController(ITrajectoryTracker):
    """
    MPC 轨迹跟踪控制器
    
    v3.17: 完善 ACADOS 集成框架，提供完整的求解流程
    
    注意: 实际部署时需要:
    1. 安装 ACADOS 和 Python 接口
    2. 根据平台类型生成对应的 OCP 求解器
    3. 配置正确的模型参数
    """
    
    def __init__(self, config: Dict[str, Any], platform_config: Dict[str, Any]):
        self.horizon = config.get('horizon', 20)
        self.dt = config.get('dt', 0.02)
        
        constraints = platform_config.get('constraints', {})
        self.v_max = constraints.get('v_max', 2.0)
        self.v_min = constraints.get('v_min', 0.0)
        self.omega_max = constraints.get('omega_max', 2.0)
        self.a_max = constraints.get('a_max', 1.5)
        self.vz_max = constraints.get('vz_max', 2.0)
        
        self.output_frame = platform_config.get('output_frame', 'base_link')
        self.platform_type = platform_config.get('type', PlatformType.DIFFERENTIAL)
        self.is_3d = self.platform_type == PlatformType.QUADROTOR
        self.is_omni = self.platform_type == PlatformType.OMNI
        
        # MPC 权重
        # v3.18: 重命名 control_v -> control_accel, control_omega -> control_alpha
        # 因为这些权重实际控制的是加速度和角加速度，而非速度
        mpc_weights = config.get('weights', {})
        self.Q_pos = mpc_weights.get('position', 10.0)
        self.Q_vel = mpc_weights.get('velocity', 1.0)
        self.Q_heading = mpc_weights.get('heading', 5.0)
        self.R_accel = mpc_weights.get('control_accel', 0.1)
        self.R_alpha = mpc_weights.get('control_alpha', 0.1)
        
        # ACADOS 求解器
        self._solver = None
        self._ocp = None
        self._is_initialized = False
        self._initialize_solver()
        
        self._last_solve_time_ms = 0.0
        self._last_kkt_residual = 0.0
        self._last_condition_number = 1.0
        self._last_cmd: Optional[ControlOutput] = None
    
    def _initialize_solver(self) -> None:
        """
        初始化 ACADOS 求解器
        
        v3.17 完善: 提供完整的 ACADOS OCP 配置框架
        
        实际部署时需要:
        1. pip install acados_template
        2. 设置 ACADOS_SOURCE_DIR 环境变量
        3. 根据平台类型调整模型参数
        """
        try:
            from acados_template import AcadosOcp, AcadosOcpSolver, AcadosModel
            import casadi as ca
            
            # 创建 ACADOS OCP
            ocp = AcadosOcp()
            
            # 定义模型
            model = AcadosModel()
            model.name = 'trajectory_tracker'
            
            # 状态变量: [px, py, pz, vx, vy, vz, theta, omega]
            px = ca.SX.sym('px')
            py = ca.SX.sym('py')
            pz = ca.SX.sym('pz')
            vx = ca.SX.sym('vx')
            vy = ca.SX.sym('vy')
            vz = ca.SX.sym('vz')
            theta = ca.SX.sym('theta')
            omega = ca.SX.sym('omega')
            x = ca.vertcat(px, py, pz, vx, vy, vz, theta, omega)
            
            # 控制输入: [a_x, a_y, a_z, alpha] (加速度和角加速度)
            ax = ca.SX.sym('ax')
            ay = ca.SX.sym('ay')
            az = ca.SX.sym('az')
            alpha = ca.SX.sym('alpha')
            u = ca.vertcat(ax, ay, az, alpha)
            
            # 参考轨迹参数
            px_ref = ca.SX.sym('px_ref')
            py_ref = ca.SX.sym('py_ref')
            pz_ref = ca.SX.sym('pz_ref')
            vx_ref = ca.SX.sym('vx_ref')
            vy_ref = ca.SX.sym('vy_ref')
            vz_ref = ca.SX.sym('vz_ref')
            theta_ref = ca.SX.sym('theta_ref')
            p = ca.vertcat(px_ref, py_ref, pz_ref, vx_ref, vy_ref, vz_ref, theta_ref)
            
            # 连续时间动力学
            if self.is_omni or self.is_3d:
                # 全向/无人机: 世界坐标系速度
                xdot = ca.vertcat(vx, vy, vz, ax, ay, az, omega, alpha)
            else:
                # 差速车: 速度-航向耦合
                v_body = ca.sqrt(vx**2 + vy**2)
                xdot = ca.vertcat(
                    v_body * ca.cos(theta),  # px_dot
                    v_body * ca.sin(theta),  # py_dot
                    vz,                       # pz_dot
                    ax * ca.cos(theta),       # vx_dot (世界系)
                    ax * ca.sin(theta),       # vy_dot (世界系)
                    az,                       # vz_dot
                    omega,                    # theta_dot
                    alpha                     # omega_dot
                )
            
            model.x = x
            model.u = u
            model.p = p
            model.f_expl_expr = xdot
            model.xdot = ca.SX.sym('xdot', 8)
            model.f_impl_expr = model.xdot - xdot
            
            ocp.model = model
            
            # 时间设置
            ocp.dims.N = self.horizon
            ocp.solver_options.tf = self.horizon * self.dt
            
            # 代价函数权重
            Q = np.diag([self.Q_pos, self.Q_pos, self.Q_pos,    # 位置
                        self.Q_vel, self.Q_vel, self.Q_vel,     # 速度
                        self.Q_heading, 0.1])                    # 航向, 角速度
            R = np.diag([self.R_v, self.R_v, self.R_v, self.R_omega])  # 控制输入
            
            ocp.cost.cost_type = 'LINEAR_LS'
            ocp.cost.cost_type_e = 'LINEAR_LS'
            
            # 输出矩阵
            Vx = np.zeros((8, 8))
            Vx[:8, :8] = np.eye(8)
            Vu = np.zeros((8, 4))
            
            ocp.cost.Vx = Vx
            ocp.cost.Vu = Vu
            ocp.cost.W = Q
            ocp.cost.W_e = Q
            ocp.cost.Vx_e = Vx[:8, :]
            
            # 约束
            ocp.constraints.lbu = np.array([-self.a_max, -self.a_max, -self.a_max, -3.0])
            ocp.constraints.ubu = np.array([self.a_max, self.a_max, self.a_max, 3.0])
            ocp.constraints.idxbu = np.array([0, 1, 2, 3])
            
            # 状态约束
            ocp.constraints.lbx = np.array([-np.inf, -np.inf, -np.inf, 
                                           -self.v_max, -self.v_max, -self.vz_max,
                                           -np.inf, -self.omega_max])
            ocp.constraints.ubx = np.array([np.inf, np.inf, np.inf,
                                           self.v_max, self.v_max, self.vz_max,
                                           np.inf, self.omega_max])
            ocp.constraints.idxbx = np.array([0, 1, 2, 3, 4, 5, 6, 7])
            
            # 初始状态约束
            ocp.constraints.x0 = np.zeros(8)
            
            # 求解器选项
            ocp.solver_options.qp_solver = 'PARTIAL_CONDENSING_HPIPM'
            ocp.solver_options.hessian_approx = 'GAUSS_NEWTON'
            ocp.solver_options.integrator_type = 'ERK'
            ocp.solver_options.nlp_solver_type = 'SQP_RTI'
            ocp.solver_options.nlp_solver_max_iter = 50
            
            # 生成求解器
            self._solver = AcadosOcpSolver(ocp, json_file='acados_ocp.json')
            self._is_initialized = True
            self._ocp = ocp
            rospy.loginfo("ACADOS MPC solver initialized successfully")
            
        except ImportError as e:
            rospy.logwarn(f"ACADOS not available ({e}), using fallback mode")
            self._is_initialized = False
        except Exception as e:
            rospy.logerr(f"ACADOS initialization failed: {e}")
            self._is_initialized = False
    
    def _solve_with_acados(self, state: np.ndarray, trajectory: Trajectory,
                          consistency: ConsistencyResult) -> ControlOutput:
        """
        使用 ACADOS 求解 MPC 问题
        
        v3.17 新增: 完整的 ACADOS 求解流程
        """
        # 设置初始状态
        self._solver.set(0, 'lbx', state)
        self._solver.set(0, 'ubx', state)
        
        # 获取参考轨迹
        ref_velocities = trajectory.velocities if trajectory.soft_enabled else trajectory.get_hard_velocities()
        
        # v3.17.4 修复: 在循环外初始化 theta_ref，确保所有分支都有定义
        theta_ref = state[6]
        
        # 设置每个阶段的参考
        for i in range(self.horizon):
            # 获取参考点
            traj_idx = min(i, len(trajectory.points) - 1)
            ref_point = trajectory.points[traj_idx]
            
            # 获取参考速度 (v3.17 修复: 使用 wz 计算参考航向)
            if ref_velocities is not None and traj_idx < len(ref_velocities):
                ref_vel = ref_velocities[traj_idx]
                vx_ref, vy_ref, vz_ref = ref_vel[0], ref_vel[1], ref_vel[2]
                wz_ref = ref_vel[3] if len(ref_vel) > 3 else 0.0
            else:
                vx_ref, vy_ref, vz_ref, wz_ref = 0.0, 0.0, 0.0, 0.0
            
            # 计算参考航向 (v3.17 修复: 优先使用 wz 积分，其次使用轨迹点方向)
            # v3.17.4 修复: 在循环外初始化 theta_ref，确保所有分支都有定义
            if i == 0:
                theta_ref = state[6]  # 第一个点使用当前航向
            elif abs(wz_ref) > 1e-3:
                # 使用 wz 积分计算航向变化
                theta_ref = theta_ref + wz_ref * self.dt
                theta_ref = np.arctan2(np.sin(theta_ref), np.cos(theta_ref))
            elif traj_idx < len(trajectory.points) - 1:
                next_point = trajectory.points[traj_idx + 1]
                dx = next_point.x - ref_point.x
                dy = next_point.y - ref_point.y
                if np.sqrt(dx**2 + dy**2) > 0.01:
                    theta_ref = np.arctan2(dy, dx)
                # else: 保持上一个 theta_ref
            
            # 应用 alpha 软约束
            alpha = consistency.alpha
            vx_ref *= alpha
            vy_ref *= alpha
            vz_ref *= alpha
            
            # 设置参考
            y_ref = np.array([ref_point.x, ref_point.y, ref_point.z,
                             vx_ref, vy_ref, vz_ref, theta_ref, 0.0])
            self._solver.set(i, 'yref', y_ref)
            
            # 设置参数
            p = np.array([ref_point.x, ref_point.y, ref_point.z,
                         vx_ref, vy_ref, vz_ref, theta_ref])
            self._solver.set(i, 'p', p)
        
        # 设置终端参考
        final_idx = min(self.horizon, len(trajectory.points) - 1)
        final_point = trajectory.points[final_idx]
        y_ref_e = np.array([final_point.x, final_point.y, final_point.z,
                          0.0, 0.0, 0.0, state[6], 0.0])
        self._solver.set(self.horizon, 'yref', y_ref_e)
        
        # 求解
        status = self._solver.solve()
        
        # 获取求解信息
        self._last_kkt_residual = self._solver.get_residuals()[0] if hasattr(self._solver, 'get_residuals') else 0.0
        
        if status != 0:
            rospy.logwarn_throttle(1.0, f"ACADOS solve failed with status {status}")
            return self._solve_fallback(state, trajectory, consistency)
        
        # 获取最优控制输入
        u_opt = self._solver.get(0, 'u')
        x_next = self._solver.get(1, 'x')
        
        # 提取速度命令
        if self.is_omni or self.is_3d:
            vx = x_next[3]
            vy = x_next[4]
            vz = x_next[5] if self.is_3d else 0.0
            omega = x_next[7]
            frame_id = "world"
        else:
            # 差速车: 转换为机体坐标系
            v_world = np.sqrt(x_next[3]**2 + x_next[4]**2)
            vx = v_world
            vy = 0.0
            vz = 0.0
            omega = x_next[7]
            frame_id = "base_link"
        
        # 应用速度平滑
        if self._last_cmd is not None:
            max_dv = self.a_max * self.dt
            vx = np.clip(vx, self._last_cmd.vx - max_dv, self._last_cmd.vx + max_dv)
            vy = np.clip(vy, self._last_cmd.vy - max_dv, self._last_cmd.vy + max_dv)
        
        result = ControlOutput(
            vx=vx, vy=vy, vz=vz, omega=omega,
            frame_id=frame_id, success=True,
            health_metrics={
                'kkt_residual': self._last_kkt_residual,
                'condition_number': self._last_condition_number,
                'solver_status': status
            }
        )
        
        self._last_cmd = result
        return result
    
    def compute(self, state: np.ndarray, trajectory: Trajectory, 
                consistency: ConsistencyResult) -> ControlOutput:
        """计算 MPC 控制输出"""
        import time
        start_time = time.time()
        
        if len(trajectory.points) < 2:
            return ControlOutput(vx=0, vy=0, vz=0, omega=0,
                               frame_id=self.output_frame, success=False)
        
        try:
            if self._is_initialized and self._solver is not None:
                result = self._solve_with_acados(state, trajectory, consistency)
            else:
                result = self._solve_fallback(state, trajectory, consistency)
            
            result.solve_time_ms = (time.time() - start_time) * 1000
            return result
        except Exception as e:
            rospy.logerr(f"MPC solve failed: {e}")
            return ControlOutput(vx=0, vy=0, vz=0, omega=0,
                               frame_id=self.output_frame, success=False)
    
    def _solve_fallback(self, state: np.ndarray, trajectory: Trajectory,
                       consistency: ConsistencyResult) -> ControlOutput:
        """
        简化的 fallback 求解器
        
        使用简单的比例控制作为 MPC 的近似
        """
        px, py, pz = state[0], state[1], state[2]
        vx_curr, vy_curr = state[3], state[4]
        theta = state[6]
        
        # 找到最近的轨迹点
        min_dist = float('inf')
        closest_idx = 0
        for i, p in enumerate(trajectory.points):
            dist = np.sqrt((p.x - px)**2 + (p.y - py)**2)
            if dist < min_dist:
                min_dist = dist
                closest_idx = i
        
        # 选择前视点
        lookahead_idx = min(closest_idx + 3, len(trajectory.points) - 1)
        target = trajectory.points[lookahead_idx]
        
        dx = target.x - px
        dy = target.y - py
        dist = np.sqrt(dx**2 + dy**2)
        
        # 计算目标速度
        if trajectory.soft_enabled and trajectory.velocities is not None:
            if lookahead_idx < len(trajectory.velocities):
                v_ref = trajectory.velocities[lookahead_idx]
                target_v = np.sqrt(v_ref[0]**2 + v_ref[1]**2) * consistency.alpha
                target_v = min(target_v, self.v_max)
            else:
                target_v = self.v_max * 0.5
        else:
            target_v = self.v_max * 0.5
        
        # 根据平台类型计算输出
        if self.is_omni or self.is_3d:
            # 全向/无人机: 世界坐标系速度
            if dist > 0.1:
                vx = target_v * dx / dist
                vy = target_v * dy / dist
            else:
                vx = 0.0
                vy = 0.0
            
            # 航向控制
            target_heading = np.arctan2(dy, dx)
            heading_error = np.arctan2(np.sin(target_heading - theta), np.cos(target_heading - theta))
            omega = 1.5 * heading_error
            omega = np.clip(omega, -self.omega_max, self.omega_max)
            
            vz = 0.0
            if self.is_3d and lookahead_idx < len(trajectory.points):
                dz = target.z - pz
                vz = np.clip(dz, -self.vz_max, self.vz_max)
            
            frame_id = "world"
        else:
            # 差速/阿克曼: 机体坐标系
            local_x = dx * np.cos(theta) + dy * np.sin(theta)
            local_y = -dx * np.sin(theta) + dy * np.cos(theta)
            
            L_sq = local_x**2 + local_y**2
            curvature = 2.0 * local_y / L_sq if L_sq > 1e-6 else 0.0
            
            omega = target_v * curvature
            omega = np.clip(omega, -self.omega_max, self.omega_max)
            
            vx = target_v
            vy = 0.0
            vz = 0.0
            frame_id = "base_link"
        
        # 应用速度平滑
        if self._last_cmd is not None:
            max_dv = self.a_max * self.dt
            vx = np.clip(vx, self._last_cmd.vx - max_dv, self._last_cmd.vx + max_dv)
            vy = np.clip(vy, self._last_cmd.vy - max_dv, self._last_cmd.vy + max_dv)
        
        self._last_kkt_residual = 0.0
        self._last_condition_number = 1.0
        
        return ControlOutput(
            vx=vx, vy=vy, vz=vz, omega=omega,
            frame_id=frame_id, success=True
        )
    
    def set_horizon(self, horizon: int) -> None:
        """
        动态调整预测 horizon
        
        v3.17.3 修复: 重新初始化求解器以使 horizon 变更生效
        """
        if horizon == self.horizon:
            return
        
        old_horizon = self.horizon
        self.horizon = horizon
        rospy.loginfo(f"MPC horizon changed from {old_horizon} to {horizon}")
        
        # 重新初始化求解器以应用新的 horizon
        if self._is_initialized:
            rospy.loginfo("Reinitializing ACADOS solver with new horizon...")
            self._initialize_solver()
    
    def get_health_metrics(self) -> Dict[str, Any]:
        """返回 MPC 健康指标"""
        return {
            'type': 'mpc',
            'horizon': self.horizon,
            'last_solve_time_ms': self._last_solve_time_ms,
            'kkt_residual': self._last_kkt_residual,
            'condition_number': self._last_condition_number,
            'acados_available': self._is_initialized
        }
    
    def shutdown(self) -> None:
        """资源清理"""
        if self._solver is not None:
            self._solver = None
        self._is_initialized = False
```
