# 通用控制器需求文档 - 一致性与健康监控

> 版本: v3.17

## 1. 加权一致性分析器 (v3.17 修复)

```python
class WeightedConsistencyAnalyzer(IConsistencyChecker):
    """
    使用加权几何平均的一致性分析器
    
    v3.17 修复:
    - temporal_valid 需要至少 2 个历史数据才返回 True
    """
    
    def __init__(self, config: Dict[str, Any]):
        self.kappa_thresh = config['kappa_thresh']
        self.v_dir_thresh = config['v_dir_thresh']
        self.temporal_smooth_thresh = config['temporal_smooth_thresh']
        self.low_speed_thresh = config.get('low_speed_thresh', 0.1)
        self.temporal_window: deque = deque(maxlen=10)
        self.w_kappa = config['weights']['kappa']
        self.w_velocity = config['weights']['velocity']
        self.w_temporal = config['weights']['temporal']
        self.alpha_min = config['alpha_min']
    
    def compute(self, trajectory: Trajectory) -> ConsistencyResult:
        if not trajectory.soft_enabled or trajectory.velocities is None:
            return ConsistencyResult(
                alpha=0.0, kappa_consistency=1.0, v_dir_consistency=1.0,
                temporal_smooth=1.0, should_disable_soft=True, data_valid=True
            )
        
        # v3.17.5 优化: 使用统一的速度获取方法
        hard_velocities = trajectory.get_hard_velocities()
        soft_velocities = trajectory.velocities  # 已确认非 None
        
        # 计算各维度一致性
        kappa_hard, kappa_hard_valid = self._compute_curvature_from_points(trajectory.points)
        kappa_soft, kappa_soft_valid = self._compute_curvature_from_velocities(
            soft_velocities, trajectory.dt_sec)
        
        if kappa_hard_valid and kappa_soft_valid:
            kappa_consistency = 1.0 - min(abs(kappa_hard - kappa_soft) / self.kappa_thresh, 1.0)
            kappa_valid = True
        else:
            kappa_consistency = 0.5
            kappa_valid = False
        
        v_dir_consistency, v_dir_valid = self._compute_velocity_direction_consistency(
            hard_velocities, soft_velocities)
        temporal_smooth, temporal_valid = self._compute_temporal_smoothness(soft_velocities)
        
        # 综合所有维度的有效性
        data_valid = kappa_valid and v_dir_valid and temporal_valid
        
        # 加权几何平均
        total_weight = self.w_kappa + self.w_velocity + self.w_temporal
        alpha = (
            (max(kappa_consistency, 1e-6) ** self.w_kappa) *
            (max(v_dir_consistency, 1e-6) ** self.w_velocity) *
            (max(temporal_smooth, 1e-6) ** self.w_temporal)
        ) ** (1.0 / total_weight) * trajectory.confidence
        
        return ConsistencyResult(
            alpha=alpha, kappa_consistency=kappa_consistency,
            v_dir_consistency=v_dir_consistency, temporal_smooth=temporal_smooth,
            should_disable_soft=(alpha < self.alpha_min),
            data_valid=data_valid
        )
```


### 1.1 辅助方法

```python
    def _compute_velocity_direction_consistency(self, v_hard: np.ndarray, 
                                                 v_soft: np.ndarray) -> Tuple[float, bool]:
        """计算速度方向一致性，返回 (consistency, data_valid)"""
        if len(v_hard) == 0 or len(v_soft) == 0:
            return 0.5, False
        
        min_len = min(len(v_hard), len(v_soft))
        v_hard = v_hard[:min_len, :2]
        v_soft = v_soft[:min_len, :2]
        dot_product = np.sum(v_hard * v_soft, axis=1)
        norms = np.linalg.norm(v_hard, axis=1) * np.linalg.norm(v_soft, axis=1)
        valid_mask = norms > 1e-6
        
        if not np.any(valid_mask):
            return 0.5, False
        
        cos_angles = dot_product[valid_mask] / norms[valid_mask]
        avg_cos = np.mean(cos_angles)
        if avg_cos >= self.v_dir_thresh:
            return 1.0, True
        return max((avg_cos + 1.0) / (self.v_dir_thresh + 1.0), 0.0), True
    
    def _compute_temporal_smoothness(self, velocities: np.ndarray) -> Tuple[float, bool]:
        """
        返回 (smoothness, data_valid)
        
        v3.17 修复: 至少需要 2 个历史数据才能计算时序平滑性
        """
        if len(velocities) > 0:
            self.temporal_window.append(velocities[0].copy())
        
        if len(self.temporal_window) >= 2:
            diffs = np.diff(np.array(list(self.temporal_window)), axis=0)
            smoothness = 1.0 - min(np.mean(np.abs(diffs)) / self.temporal_smooth_thresh, 1.0)
            return smoothness, True
        
        # v3.17 修复: 数据不足时返回中性值和 data_valid=False
        return 1.0, False
    
    def _compute_curvature_from_points(self, points: List[Point3D]) -> Tuple[float, bool]:
        """返回 (curvature, data_valid)"""
        if len(points) < 3:
            return 0.0, False
        
        p0 = np.array([points[0].x, points[0].y])
        p1 = np.array([points[1].x, points[1].y])
        p2 = np.array([points[2].x, points[2].y])
        v1, v2 = p1 - p0, p2 - p1
        l1, l2 = np.linalg.norm(v1), np.linalg.norm(v2)
        
        if l1 < 1e-6 or l2 < 1e-6:
            return 0.0, False
        
        cross = v1[0] * v2[1] - v1[1] * v2[0]
        l12 = np.linalg.norm(p2 - p0)
        
        if l12 < 1e-6:
            return 0.0, False
        
        return 2.0 * abs(cross) / (l1 * l2 * l12), True
    
    def _compute_curvature_from_velocities(self, velocities: np.ndarray, dt: float) -> Tuple[float, bool]:
        """返回 (curvature, data_valid)"""
        if len(velocities) < 2:
            return 0.0, False
        
        if dt <= 0:
            rospy.logwarn_throttle(1.0, "Invalid dt in curvature computation")
            return 0.0, False
        
        v = velocities[0, :2]
        v_next = velocities[1, :2]
        a = (v_next - v) / dt
        v_norm = np.linalg.norm(v)
        
        if v_norm < self.low_speed_thresh:
            return 0.0, False
        
        cross = v[0] * a[1] - v[1] * a[0]
        return abs(cross) / (v_norm ** 3), True
    
    def reset(self) -> None:
        self.temporal_window.clear()
```

---

## 2. MPC 健康监控器

```python
class MPCHealthMonitor:
    """MPC 求解器健康监控，支持预测性降级"""
    
    def __init__(self, config: Dict[str, Any]):
        self.time_warning_thresh = config['time_warning_thresh_ms']
        self.time_critical_thresh = config['time_critical_thresh_ms']
        self.time_recovery_thresh = config.get('time_recovery_thresh_ms', 6)
        self.condition_number_thresh = config['condition_number_thresh']
        self.condition_number_recovery = config.get('condition_number_recovery', 1e5)
        self.kkt_residual_thresh = config['kkt_residual_thresh']
        self.consecutive_warning_limit = config['consecutive_warning_limit']
        self.consecutive_recovery_limit = config.get('consecutive_recovery_limit', 5)
        
        self.consecutive_near_timeout = 0
        self.consecutive_good = 0
        self.degradation_warning = False
        self._can_recover = False
    
    def update(self, solve_time_ms: float, kkt_residual: float, 
               condition_number: float) -> MPCHealthStatus:
        # 更新连续超时计数
        if solve_time_ms > self.time_warning_thresh:
            self.consecutive_near_timeout += 1
            self.consecutive_good = 0
        elif solve_time_ms < self.time_recovery_thresh:
            self.consecutive_good += 1
            if self.consecutive_good >= 2:
                self.consecutive_near_timeout = max(0, self.consecutive_near_timeout - 2)
        else:
            self.consecutive_good = 0
            self.consecutive_near_timeout = max(0, self.consecutive_near_timeout - 1)
        
        # 判断是否需要警告
        should_warn = (
            self.consecutive_near_timeout >= self.consecutive_warning_limit or
            condition_number > self.condition_number_thresh or
            kkt_residual > self.kkt_residual_thresh
        )
        self.degradation_warning = should_warn
        
        # 判断是否可以恢复
        self._can_recover = (
            self.consecutive_good >= self.consecutive_recovery_limit and
            condition_number < self.condition_number_recovery
        )
        
        return MPCHealthStatus(
            healthy=not should_warn and solve_time_ms < self.time_critical_thresh,
            warning=should_warn, can_recover=self._can_recover,
            consecutive_near_timeout=self.consecutive_near_timeout,
            kkt_residual=kkt_residual, condition_number=condition_number
        )
    
    def should_preemptive_switch(self) -> bool:
        return self.degradation_warning
    
    def reset(self) -> None:
        self.consecutive_near_timeout = 0
        self.consecutive_good = 0
        self.degradation_warning = False
        self._can_recover = False
```
