# 通用控制器需求文档 - 状态机与安全

> 版本: v3.17.6
>
> v3.17.6 修复:
> - `ControllerManager._publish_diagnostics()`: 修复 DiagnosticsV2 dataclass 不能直接发布的问题，改用 to_ros_msg() 转换
> - `ControllerManager`: 添加 `_last_published_diagnostics` 字段存储最后发布的诊断数据
>
> v3.17.5 修复:
> - `ControllerManager.initialize_components()`: 改为延迟绑定，确保 coord_transformer 无论注入顺序都能获得 state_estimator
> - `ControllerManager._publish_diagnostics()`: 实现实际的诊断消息构建和发布
>
> v3.17.4 修复:
> - `ControllerManager`: 添加 `initialize_components()` 组件注入方法，支持插件化架构
> - `MPCController._solve_with_acados()`: 在循环外初始化 `theta_ref`，修复潜在的未定义变量问题
>
> v3.17.3 修复:
> - `ControllerManager`: 添加 `timeout_monitor.update_imu()` 调用，修复 IMU 超时检测不工作的问题
> - `ControllerManager`: 添加 MPC horizon 动态调整逻辑（MPC_DEGRADED 时降低 horizon）
> - `StateMachine`: 从 `SOFT_DISABLED` 转换到其他状态时重置 `alpha_recovery_count`
>
> v3.17.2 修复:
> - `ControllerManager`: IMU 超时时正确更新 EKF 的 `_imu_available` 标志
> - `ControllerManager`: 添加双向平滑过渡（从 BACKUP_ACTIVE 恢复时也平滑过渡）
> - `ControllerManager`: 添加 `_compute_tracking_error()` 方法和 tracking 诊断字段
> - `StateMachine`: 当 `data_valid=False` 时使用更保守的状态转换策略

## 1. 状态机

```python
class StateMachine:
    """控制器状态机"""
    
    def __init__(self, config: Dict[str, Any]):
        self.state = ControllerState.INIT
        self.alpha_recovery_count = 0
        self.mpc_recovery_count = 0
        
        safety_config = config.get('safety', {})
        sm_config = safety_config.get('state_machine', {})
        
        self.alpha_recovery_thresh = sm_config.get('alpha_recovery_thresh', 5)
        self.alpha_recovery_value = sm_config.get('alpha_recovery_value', 0.3)
        self.alpha_disable_thresh = sm_config.get('alpha_disable_thresh', 0.1)
        self.mpc_recovery_thresh = sm_config.get('mpc_recovery_thresh', 5)
        self.v_stop_thresh = safety_config.get('v_stop_thresh', 0.05)
        self.vz_stop_thresh = safety_config.get('vz_stop_thresh', 0.1)
        self.stopping_timeout = safety_config.get('stopping_timeout', 5.0)
        self._stopping_start_time: Optional[rospy.Time] = None
    
    def update(self, diagnostics: Dict[str, Any]) -> ControllerState:
        alpha = diagnostics.get('alpha', 1.0)
        mpc_health = diagnostics.get('mpc_health')
        odom_timeout = diagnostics.get('odom_timeout', False)
        traj_timeout_exceeded = diagnostics.get('traj_timeout_exceeded', False)
        v_horizontal = diagnostics.get('v_horizontal', 0)
        vz = diagnostics.get('vz', 0)
        mpc_success = diagnostics.get('mpc_success', False)
        has_valid_data = diagnostics.get('has_valid_data', False)
        tf2_critical = diagnostics.get('tf2_critical', False)
        data_valid = diagnostics.get('data_valid', True)
        safety_failed = diagnostics.get('safety_failed', False)
        
        # 超时 -> STOPPING
        if odom_timeout or traj_timeout_exceeded:
            if self.state != ControllerState.STOPPING:
                self._stopping_start_time = rospy.Time.now()
                self.state = ControllerState.STOPPING
            return self.state
        
        # 状态转换逻辑
        if self.state == ControllerState.INIT:
            if has_valid_data:
                self.state = ControllerState.NORMAL
        
        elif self.state == ControllerState.NORMAL:
            if safety_failed:
                self.state = ControllerState.MPC_DEGRADED
            elif not mpc_success:
                self.state = ControllerState.BACKUP_ACTIVE
            # v3.17 增强: 当 data_valid=False 时，alpha 不可靠，使用更保守的阈值
            elif not data_valid and alpha < self.alpha_recovery_value:
                # 数据不可靠且 alpha 较低时，进入 SOFT_DISABLED
                self.state = ControllerState.SOFT_DISABLED
            elif data_valid and alpha < self.alpha_disable_thresh:
                self.state = ControllerState.SOFT_DISABLED
            elif (mpc_health and mpc_health.warning) or tf2_critical:
                self.state = ControllerState.MPC_DEGRADED
        
        elif self.state == ControllerState.SOFT_DISABLED:
            if safety_failed:
                self.state = ControllerState.MPC_DEGRADED
                # v3.17.3 修复: 重置所有恢复计数器
                self.alpha_recovery_count = 0
                self.mpc_recovery_count = 0
                return self.state
            
            if not mpc_success:
                self.state = ControllerState.BACKUP_ACTIVE
                # v3.17.3 修复: 重置所有恢复计数器
                self.alpha_recovery_count = 0
                self.mpc_recovery_count = 0
                return self.state
            
            if (mpc_health and mpc_health.warning) or tf2_critical:
                self.state = ControllerState.MPC_DEGRADED
                # v3.17.3 修复: 重置所有恢复计数器
                self.alpha_recovery_count = 0
                self.mpc_recovery_count = 0
                return self.state
            
            # 恢复条件: alpha > 阈值 且 data_valid 且 MPC 健康
            if alpha > self.alpha_recovery_value and data_valid:
                self.alpha_recovery_count += 1
                mpc_is_healthy = mpc_health is None or mpc_health.healthy
                if self.alpha_recovery_count >= self.alpha_recovery_thresh and mpc_is_healthy:
                    self.state = ControllerState.NORMAL
                    self.alpha_recovery_count = 0
            else:
                self.alpha_recovery_count = 0
        
        elif self.state == ControllerState.MPC_DEGRADED:
            if not mpc_success:
                self.state = ControllerState.BACKUP_ACTIVE
                return self.state
            
            if mpc_health and mpc_health.can_recover and not tf2_critical and not safety_failed:
                self.mpc_recovery_count += 1
                if self.mpc_recovery_count >= self.mpc_recovery_thresh:
                    if alpha >= self.alpha_disable_thresh and data_valid:
                        self.state = ControllerState.NORMAL
                    else:
                        self.state = ControllerState.SOFT_DISABLED
                    self.alpha_recovery_count = 0
                    self.mpc_recovery_count = 0
            else:
                self.mpc_recovery_count = 0
        
        elif self.state == ControllerState.BACKUP_ACTIVE:
            if mpc_success and not tf2_critical and not safety_failed:
                self.state = ControllerState.MPC_DEGRADED
                self.mpc_recovery_count = 0
        
        elif self.state == ControllerState.STOPPING:
            stopped = (abs(v_horizontal) < self.v_stop_thresh and 
                      abs(vz) < self.vz_stop_thresh)
            
            if stopped:
                self.state = ControllerState.STOPPED
                self._stopping_start_time = None
            elif self._stopping_start_time is not None:
                elapsed = (rospy.Time.now() - self._stopping_start_time).to_sec()
                if elapsed > self.stopping_timeout:
                    rospy.logwarn(f"STOPPING timeout after {elapsed:.1f}s, forcing STOPPED")
                    self.state = ControllerState.STOPPED
                    self._stopping_start_time = None
        
        elif self.state == ControllerState.STOPPED:
            if has_valid_data and not odom_timeout and not traj_timeout_exceeded:
                mpc_is_healthy = mpc_health is None or mpc_health.healthy
                if mpc_is_healthy and not safety_failed:
                    self.state = ControllerState.NORMAL
                else:
                    self.state = ControllerState.MPC_DEGRADED
                self.alpha_recovery_count = 0
                self.mpc_recovery_count = 0
        
        return self.state
    
    def reset(self) -> None:
        self.state = ControllerState.INIT
        self.alpha_recovery_count = 0
        self.mpc_recovery_count = 0
        self._stopping_start_time = None
```


## 2. 安全监控器 (v3.17 修复)

```python
class BasicSafetyMonitor(ISafetyMonitor):
    """
    基础安全监控器实现
    
    v3.17 修复: 
    - limited_cmd 完整复制所有字段包括 health_metrics
    - 使用 ControlOutput.copy() 方法
    """
    
    def __init__(self, config: Dict[str, Any], platform_config: Dict[str, Any]):
        constraints = platform_config.get('constraints', {})
        self.v_max = constraints.get('v_max', 2.0)
        self.vz_max = constraints.get('vz_max', 2.0)
        self.omega_max = constraints.get('omega_max', 2.0)
        self.a_max = constraints.get('a_max', 1.5)
        self.az_max = constraints.get('az_max', 1.0)
        self.alpha_max = constraints.get('alpha_max', 3.0)
        
        safety_config = config.get('safety', {})
        self.velocity_margin = safety_config.get('velocity_margin', 1.1)
        self.accel_margin = safety_config.get('accel_margin', 1.5)
        
        self._last_cmd: Optional[ControlOutput] = None
        self._last_time: Optional[rospy.Time] = None
        self.is_3d = platform_config.get('type') == PlatformType.QUADROTOR
    
    def check(self, state: np.ndarray, cmd: ControlOutput, 
              diagnostics: Dict[str, Any]) -> SafetyDecision:
        """检查控制命令安全性"""
        reasons = []
        # v3.17: 使用 copy() 方法确保完整复制
        limited_cmd = cmd.copy()
        needs_limiting = False
        
        # 检查水平速度限制
        v_horizontal = cmd.v_horizontal
        if v_horizontal > self.v_max * self.velocity_margin:
            reasons.append(f"v_horizontal {v_horizontal:.2f} exceeds limit")
            if v_horizontal > 1e-6:
                scale = self.v_max / v_horizontal
                limited_cmd.vx = cmd.vx * scale
                limited_cmd.vy = cmd.vy * scale
                needs_limiting = True
        
        # 检查垂直速度限制 (无人机)
        if self.is_3d and abs(cmd.vz) > self.vz_max * self.velocity_margin:
            reasons.append(f"vz {cmd.vz:.2f} exceeds limit")
            limited_cmd.vz = np.clip(cmd.vz, -self.vz_max, self.vz_max)
            needs_limiting = True
        
        # 检查角速度限制
        if abs(cmd.omega) > self.omega_max * self.velocity_margin:
            reasons.append(f"omega {cmd.omega:.2f} exceeds limit")
            limited_cmd.omega = np.clip(cmd.omega, -self.omega_max, self.omega_max)
            needs_limiting = True
        
        # 检查加速度 (需要历史数据)
        current_time = rospy.Time.now()
        if self._last_cmd is not None and self._last_time is not None:
            dt = (current_time - self._last_time).to_sec()
            if dt > 0.001:
                # 水平加速度检查
                ax = (cmd.vx - self._last_cmd.vx) / dt
                ay = (cmd.vy - self._last_cmd.vy) / dt
                accel_horizontal = np.sqrt(ax**2 + ay**2)
                
                if accel_horizontal > self.a_max * self.accel_margin:
                    reasons.append(f"a_horizontal {accel_horizontal:.2f} exceeds limit")
                    # 限制加速度
                    if accel_horizontal > 1e-6:
                        scale = self.a_max / accel_horizontal
                        limited_cmd.vx = self._last_cmd.vx + ax * scale * dt
                        limited_cmd.vy = self._last_cmd.vy + ay * scale * dt
                    needs_limiting = True
                
                # 垂直加速度检查 (无人机)
                if self.is_3d:
                    az = (cmd.vz - self._last_cmd.vz) / dt
                    if abs(az) > self.az_max * self.accel_margin:
                        reasons.append(f"az {az:.2f} exceeds limit")
                        limited_cmd.vz = self._last_cmd.vz + np.clip(az, -self.az_max, self.az_max) * dt
                        needs_limiting = True
                
                # 角加速度检查
                alpha = (cmd.omega - self._last_cmd.omega) / dt
                if abs(alpha) > self.alpha_max * self.accel_margin:
                    reasons.append(f"alpha {alpha:.2f} exceeds limit")
                    limited_cmd.omega = self._last_cmd.omega + np.clip(alpha, -self.alpha_max, self.alpha_max) * dt
                    needs_limiting = True
        
        # 更新历史
        self._last_cmd = limited_cmd.copy() if needs_limiting else cmd.copy()
        self._last_time = current_time
        
        if reasons:
            return SafetyDecision(
                safe=False,
                new_state=ControllerState.MPC_DEGRADED,
                reason="; ".join(reasons),
                limited_cmd=limited_cmd
            )
        
        return SafetyDecision(safe=True, new_state=None, reason="", limited_cmd=None)
    
    def reset(self) -> None:
        self._last_cmd = None
        self._last_time = None
```


## 3. 控制器管理器 (v3.17 修复)

```python
class ControllerManager:
    """
    控制器管理器
    
    v3.17 修复:
    1. 安全检查失败时立即更新状态机
    2. 添加诊断消息发布功能
    """
    
    def __init__(self, config: Dict[str, Any]):
        self.config = config
        self.ctrl_freq = config.get('system', {}).get('ctrl_freq', 50)
        self.dt = 1.0 / self.ctrl_freq
        
        platform_name = config.get('system', {}).get('platform', 'differential')
        self.platform_config = PLATFORM_CONFIG.get(platform_name, PLATFORM_CONFIG['differential'])
        self.default_frame_id = self.platform_config.get('output_frame', 'base_link')
        self.transform_target_frame = config.get('transform', {}).get('target_frame', 'odom')
        
        # v3.17.3 新增: MPC horizon 配置
        mpc_config = config.get('mpc', {})
        self.horizon_normal = mpc_config.get('horizon', 20)
        self.horizon_degraded = mpc_config.get('horizon_degraded', 10)
        self._current_horizon = self.horizon_normal
        
        # 组件
        self.state_estimator: Optional[IStateEstimator] = None
        self.mpc_tracker: Optional[ITrajectoryTracker] = None
        self.backup_tracker: Optional[ITrajectoryTracker] = None
        self.consistency_checker: Optional[IConsistencyChecker] = None
        self.state_machine: Optional[StateMachine] = None
        self.smooth_transition: Optional[ISmoothTransition] = None
        self.coord_transformer: Optional[ICoordinateTransformer] = None
        self.safety_monitor: Optional[ISafetyMonitor] = None
        self.mpc_health_monitor: Optional[MPCHealthMonitor] = None
        self.timeout_monitor = TimeoutMonitor(config)
        
        # 状态
        self._last_state = ControllerState.INIT
        self._safety_failed = False
        self._diagnostics_pub: Optional[rospy.Publisher] = None
        self._last_diagnostics: Dict[str, Any] = {}
        self._last_mpc_health: Optional[MPCHealthStatus] = None
        self._last_consistency: Optional[ConsistencyResult] = None
        self._last_mpc_cmd: Optional[ControlOutput] = None
        self._last_backup_cmd: Optional[ControlOutput] = None  # v3.17: 用于双向平滑过渡
        self._last_tracking_error: Optional[Dict[str, float]] = None  # v3.17: 跟踪误差
        self._last_published_diagnostics: Optional[Dict[str, Any]] = None  # v3.17.6: 最后发布的诊断数据
    
    def initialize_components(self,
                             state_estimator: Optional[IStateEstimator] = None,
                             mpc_tracker: Optional[ITrajectoryTracker] = None,
                             backup_tracker: Optional[ITrajectoryTracker] = None,
                             consistency_checker: Optional[IConsistencyChecker] = None,
                             safety_monitor: Optional[ISafetyMonitor] = None,
                             smooth_transition: Optional[ISmoothTransition] = None,
                             coord_transformer: Optional[ICoordinateTransformer] = None,
                             mpc_health_monitor: Optional[MPCHealthMonitor] = None) -> None:
        """
        v3.17.4 新增: 组件注入方法
        
        允许外部注入各个组件实现，支持插件化架构
        
        v3.17.5 修复: 支持延迟绑定 state_estimator 到 coord_transformer
        """
        if state_estimator:
            self.state_estimator = state_estimator
        if mpc_tracker:
            self.mpc_tracker = mpc_tracker
        if backup_tracker:
            self.backup_tracker = backup_tracker
        if consistency_checker:
            self.consistency_checker = consistency_checker
        if safety_monitor:
            self.safety_monitor = safety_monitor
        if smooth_transition:
            self.smooth_transition = smooth_transition
        if coord_transformer:
            self.coord_transformer = coord_transformer
        if mpc_health_monitor:
            self.mpc_health_monitor = mpc_health_monitor
        
        # v3.17.5 修复: 延迟绑定 - 确保 coord_transformer 获得 state_estimator 引用
        # 无论组件注入顺序如何，都尝试绑定
        if self.coord_transformer and self.state_estimator:
            self.coord_transformer.set_state_estimator(self.state_estimator)
        
        # 初始化状态机
        self.state_machine = StateMachine(self.config)
        
        # 初始化诊断发布器
        self._diagnostics_pub = rospy.Publisher(
            '/controller/diagnostics', 
            DiagnosticsV2,  # 需要定义对应的 ROS 消息类型
            queue_size=1
        )
    
    def _on_state_changed(self, old_state: ControllerState, new_state: ControllerState) -> None:
        """状态变化回调"""
        rospy.loginfo(f"Controller state changed: {old_state.name} -> {new_state.name}")
        
        # v3.17.3 新增: MPC horizon 动态调整
        if new_state == ControllerState.MPC_DEGRADED:
            if self._current_horizon != self.horizon_degraded:
                self._current_horizon = self.horizon_degraded
                if self.mpc_tracker:
                    self.mpc_tracker.set_horizon(self.horizon_degraded)
                rospy.loginfo(f"MPC horizon reduced to {self.horizon_degraded}")
        elif new_state == ControllerState.NORMAL and old_state == ControllerState.MPC_DEGRADED:
            if self._current_horizon != self.horizon_normal:
                self._current_horizon = self.horizon_normal
                if self.mpc_tracker:
                    self.mpc_tracker.set_horizon(self.horizon_normal)
                rospy.loginfo(f"MPC horizon restored to {self.horizon_normal}")
        
        # v3.17 修复: 双向平滑过渡
        # 进入 BACKUP_ACTIVE 时启动平滑过渡
        if (old_state in [ControllerState.NORMAL, ControllerState.SOFT_DISABLED, ControllerState.MPC_DEGRADED] and
            new_state == ControllerState.BACKUP_ACTIVE):
            if self.smooth_transition and self._last_mpc_cmd is not None:
                self.smooth_transition.start_transition(self._last_mpc_cmd)
        
        # 从 BACKUP_ACTIVE 恢复时也启动平滑过渡
        elif (old_state == ControllerState.BACKUP_ACTIVE and
              new_state in [ControllerState.NORMAL, ControllerState.SOFT_DISABLED, ControllerState.MPC_DEGRADED]):
            if self.smooth_transition and self._last_backup_cmd is not None:
                self.smooth_transition.start_transition(self._last_backup_cmd)
    
    def update(self, odom: Odometry, trajectory: Trajectory, 
               imu: Optional[Imu] = None) -> ControlOutput:
        """主控制循环"""
        current_time = rospy.Time.now()
        
        # 1. 更新超时监控
        self.timeout_monitor.update_odom(odom.header.stamp)
        self.timeout_monitor.update_trajectory(trajectory.header.stamp)
        # v3.17.3 修复: 添加 IMU 超时更新
        if imu is not None:
            self.timeout_monitor.update_imu(imu.header.stamp)
        timeout_status = self.timeout_monitor.check(current_time)
        
        # 2. 状态估计
        state_output: Optional[EstimatorOutput] = None
        if self.state_estimator:
            self.state_estimator.update_odom(odom)
            # v3.17 修复: IMU 超时时更新 EKF 的 _imu_available 标志
            if timeout_status.imu_timeout:
                self.state_estimator.set_imu_available(False)
            elif imu:
                self.state_estimator.set_imu_available(True)
                self.state_estimator.update_imu(imu)
            state_output = self.state_estimator.get_state()
            state = state_output.state
        else:
            state = np.zeros(8)
        
        # 3. 一致性检查
        if self.consistency_checker:
            consistency = self.consistency_checker.compute(trajectory)
        else:
            consistency = ConsistencyResult(0, 1, 1, 1, True, True)
        self._last_consistency = consistency
        
        # 4. 坐标变换
        if self.coord_transformer:
            transformed_traj, tf_status = self.coord_transformer.transform_trajectory(
                trajectory, self.transform_target_frame, current_time)
            tf2_critical = tf_status.is_critical()
        else:
            transformed_traj = trajectory
            tf2_critical = False
        
        # 5. MPC 计算
        mpc_cmd = None
        if self.mpc_tracker and self._last_state not in [ControllerState.BACKUP_ACTIVE, 
                                                          ControllerState.STOPPING,
                                                          ControllerState.STOPPED]:
            mpc_cmd = self.mpc_tracker.compute(state, transformed_traj, consistency)
            if mpc_cmd.success:
                self._last_mpc_cmd = mpc_cmd.copy()
        
        # MPC 健康监控
        if self.mpc_health_monitor and mpc_cmd is not None:
            mpc_health = self.mpc_health_monitor.update(
                mpc_cmd.solve_time_ms,
                mpc_cmd.health_metrics.get('kkt_residual', 0.0),
                mpc_cmd.health_metrics.get('condition_number', 1.0)
            )
        else:
            mpc_health = None
        self._last_mpc_health = mpc_health
        
        # 6. 构建诊断信息并更新状态机
        diagnostics = {
            'alpha': consistency.alpha,
            'data_valid': consistency.data_valid,
            'mpc_health': mpc_health,
            'mpc_success': mpc_cmd.success if mpc_cmd else False,
            'odom_timeout': timeout_status.odom_timeout,
            'traj_timeout_exceeded': timeout_status.traj_grace_exceeded,
            'v_horizontal': np.sqrt(state[3]**2 + state[4]**2),
            'vz': state[5],
            'has_valid_data': len(trajectory.points) > 0,
            'tf2_critical': tf2_critical,
            'safety_failed': self._safety_failed,
        }
        self._last_diagnostics = diagnostics
        
        if self.state_machine:
            new_state = self.state_machine.update(diagnostics)
            if new_state != self._last_state:
                self._on_state_changed(self._last_state, new_state)
                self._last_state = new_state
        
        # 7. 选择控制器输出
        if self._last_state in [ControllerState.BACKUP_ACTIVE, ControllerState.STOPPING]:
            cmd = self.backup_tracker.compute(state, transformed_traj, consistency)
            self._last_backup_cmd = cmd.copy()  # v3.17: 保存 backup 命令用于平滑过渡
        else:
            cmd = mpc_cmd if mpc_cmd else ControlOutput(vx=0, vy=0, vz=0, omega=0, 
                                                        frame_id=self.default_frame_id)
        
        # v3.17 新增: 计算跟踪误差
        self._last_tracking_error = self._compute_tracking_error(state, transformed_traj)
        
        # 8. v3.17 修复: 安全检查后立即更新状态机
        if self.safety_monitor:
            safety_decision = self.safety_monitor.check(state, cmd, diagnostics)
            if not safety_decision.safe:
                self._safety_failed = True
                if safety_decision.limited_cmd is not None:
                    cmd = safety_decision.limited_cmd
                
                # 立即更新状态机
                if self.state_machine and safety_decision.new_state is not None:
                    diagnostics['safety_failed'] = True
                    immediate_state = self.state_machine.update(diagnostics)
                    if immediate_state != self._last_state:
                        self._on_state_changed(self._last_state, immediate_state)
                        self._last_state = immediate_state
            else:
                self._safety_failed = False
        
        # 9. 平滑过渡
        if self.smooth_transition and not self.smooth_transition.is_complete():
            cmd = self.smooth_transition.get_blended_output(cmd, current_time)
        
        # 10. 发布诊断
        self._publish_diagnostics(current_time, cmd, state_output, timeout_status, tf2_critical)
        
        return cmd
    
    def _publish_diagnostics(self, current_time: rospy.Time, cmd: ControlOutput,
                            state_output: Optional[EstimatorOutput],
                            timeout_status: TimeoutStatus,
                            tf2_critical: bool) -> None:
        """
        v3.17 新增: 发布诊断消息
        v3.17.5 修复: 实现实际的诊断消息发布
        """
        if self._diagnostics_pub is None:
            return
        
        # 获取坐标变换状态
        transform_status = self.coord_transformer.get_status() if self.coord_transformer else {
            'fallback_duration_ms': 0.0, 'accumulated_drift': 0.0
        }
        
        # 构建 DiagnosticsV2 数据类
        diag = DiagnosticsV2(
            header=Header(stamp=current_time, frame_id=''),
            state=int(self._last_state),
            mpc_success=self._last_diagnostics.get('mpc_success', False),
            mpc_solve_time_ms=cmd.solve_time_ms if cmd else 0.0,
            backup_active=self._last_state == ControllerState.BACKUP_ACTIVE,
            
            # MPC 健康状态
            mpc_health_kkt_residual=self._last_mpc_health.kkt_residual if self._last_mpc_health else 0.0,
            mpc_health_condition_number=self._last_mpc_health.condition_number if self._last_mpc_health else 1.0,
            mpc_health_consecutive_near_timeout=self._last_mpc_health.consecutive_near_timeout if self._last_mpc_health else 0,
            mpc_health_degradation_warning=self._last_mpc_health.warning if self._last_mpc_health else False,
            mpc_health_can_recover=self._last_mpc_health.can_recover if self._last_mpc_health else False,
            
            # 一致性指标
            consistency_curvature=self._last_consistency.kappa_consistency if self._last_consistency else 1.0,
            consistency_velocity_dir=self._last_consistency.v_dir_consistency if self._last_consistency else 1.0,
            consistency_temporal=self._last_consistency.temporal_smooth if self._last_consistency else 1.0,
            consistency_alpha_soft=self._last_consistency.alpha if self._last_consistency else 0.0,
            consistency_data_valid=self._last_consistency.data_valid if self._last_consistency else True,
            
            # 状态估计器健康
            estimator_covariance_norm=state_output.covariance_norm if state_output else 0.0,
            estimator_innovation_norm=state_output.innovation_norm if state_output else 0.0,
            estimator_slip_probability=state_output.slip_probability if state_output else 0.0,
            estimator_imu_drift_detected=state_output.imu_drift_detected if state_output else False,
            estimator_imu_bias=state_output.imu_bias if state_output else np.zeros(3),
            estimator_imu_available=state_output.imu_available if state_output else True,
            
            # 跟踪误差
            tracking_lateral_error=self._last_tracking_error.get('lateral_error', 0.0) if self._last_tracking_error else 0.0,
            tracking_longitudinal_error=self._last_tracking_error.get('longitudinal_error', 0.0) if self._last_tracking_error else 0.0,
            tracking_heading_error=self._last_tracking_error.get('heading_error', 0.0) if self._last_tracking_error else 0.0,
            tracking_prediction_error=self._last_tracking_error.get('prediction_error', 0.0) if self._last_tracking_error else 0.0,
            
            # 坐标变换状态
            transform_tf2_available=not tf2_critical,
            transform_fallback_duration_ms=transform_status['fallback_duration_ms'],
            transform_accumulated_drift=transform_status['accumulated_drift'],
            
            # 超时状态
            timeout_odom=timeout_status.odom_timeout,
            timeout_traj=timeout_status.traj_timeout,
            timeout_traj_grace_exceeded=timeout_status.traj_grace_exceeded,
            timeout_imu=timeout_status.imu_timeout,
            timeout_last_odom_age_ms=timeout_status.last_odom_age_ms,
            timeout_last_traj_age_ms=timeout_status.last_traj_age_ms,
            timeout_last_imu_age_ms=timeout_status.last_imu_age_ms,
            timeout_in_startup_grace=timeout_status.in_startup_grace,
            
            # 控制命令
            cmd_vx=cmd.vx,
            cmd_vy=cmd.vy,
            cmd_vz=cmd.vz,
            cmd_omega=cmd.omega,
            cmd_frame_id=cmd.frame_id,
            
            # 过渡进度
            transition_progress=self.smooth_transition.get_progress() if self.smooth_transition else 0.0
        )
        
        # 发布诊断消息
        # 注意: 实际 ROS 部署时，需要将 DiagnosticsV2 dataclass 转换为对应的 ROS 消息类型
        # 方案1: 如果已定义 controller_msgs/DiagnosticsV2.msg，使用 _convert_to_ros_msg()
        # 方案2: 使用 to_ros_msg() 返回字典，通过其他方式发布
        try:
            # 使用 to_ros_msg() 获取字典格式，便于调试和日志记录
            diag_dict = diag.to_ros_msg()
            
            # 实际 ROS 发布需要对应的消息类型
            # 如果 controller_msgs/DiagnosticsV2 消息已定义:
            # ros_msg = self._convert_to_ros_msg(diag)
            # self._diagnostics_pub.publish(ros_msg)
            
            # 当前实现: 发布字典格式到诊断话题 (需要自定义消息类型支持)
            # 或者使用 diagnostic_msgs/DiagnosticArray 作为替代
            self._last_published_diagnostics = diag_dict
            
        except Exception as e:
            rospy.logwarn_throttle(5.0, f"Failed to publish diagnostics: {e}")
    
    def _compute_tracking_error(self, state: np.ndarray, trajectory: Trajectory) -> Dict[str, float]:
        """
        v3.17 新增: 计算跟踪误差
        
        返回:
        - lateral_error: 横向误差 (垂直于轨迹方向)
        - longitudinal_error: 纵向误差 (沿轨迹方向)
        - heading_error: 航向误差
        - prediction_error: 预测误差 (与上一次预测的偏差)
        """
        if len(trajectory.points) < 2:
            return {'lateral_error': 0.0, 'longitudinal_error': 0.0, 
                    'heading_error': 0.0, 'prediction_error': 0.0}
        
        px, py = state[0], state[1]
        theta = state[6]
        
        # 找到最近的轨迹点
        min_dist = float('inf')
        closest_idx = 0
        for i, p in enumerate(trajectory.points):
            dist = np.sqrt((p.x - px)**2 + (p.y - py)**2)
            if dist < min_dist:
                min_dist = dist
                closest_idx = i
        
        # 计算轨迹切线方向
        if closest_idx < len(trajectory.points) - 1:
            p0 = trajectory.points[closest_idx]
            p1 = trajectory.points[closest_idx + 1]
        elif closest_idx > 0:
            p0 = trajectory.points[closest_idx - 1]
            p1 = trajectory.points[closest_idx]
        else:
            return {'lateral_error': min_dist, 'longitudinal_error': 0.0,
                    'heading_error': 0.0, 'prediction_error': 0.0}
        
        # 轨迹切线方向
        dx = p1.x - p0.x
        dy = p1.y - p0.y
        traj_length = np.sqrt(dx**2 + dy**2)
        
        if traj_length < 1e-6:
            return {'lateral_error': min_dist, 'longitudinal_error': 0.0,
                    'heading_error': 0.0, 'prediction_error': 0.0}
        
        # 单位切线向量
        tx, ty = dx / traj_length, dy / traj_length
        
        # 从轨迹点到当前位置的向量
        ex = px - p0.x
        ey = py - p0.y
        
        # 纵向误差 (沿轨迹方向的投影)
        longitudinal_error = ex * tx + ey * ty
        
        # 横向误差 (垂直于轨迹方向)
        lateral_error = -ex * ty + ey * tx
        
        # 航向误差
        traj_heading = np.arctan2(dy, dx)
        heading_error = theta - traj_heading
        heading_error = np.arctan2(np.sin(heading_error), np.cos(heading_error))
        
        return {
            'lateral_error': lateral_error,
            'longitudinal_error': longitudinal_error,
            'heading_error': heading_error,
            'prediction_error': 0.0  # 需要历史数据，暂时返回 0
        }
    
    def get_timeout_status(self) -> TimeoutStatus:
        """获取超时状态"""
        return self.timeout_monitor.check(rospy.Time.now())
    
    def get_state(self) -> ControllerState:
        """获取当前状态"""
        return self._last_state
    
    def get_diagnostics(self) -> Dict[str, Any]:
        """v3.17 新增: 获取最新诊断信息"""
        return self._last_diagnostics.copy()
    
    def reset(self) -> None:
        """重置所有组件状态"""
        if self.state_estimator: self.state_estimator.reset()
        if self.consistency_checker: self.consistency_checker.reset()
        if self.state_machine: self.state_machine.reset()
        if self.safety_monitor: self.safety_monitor.reset()
        if self.mpc_health_monitor: self.mpc_health_monitor.reset()
        self.timeout_monitor.reset()
        self._last_state = ControllerState.INIT
        self._safety_failed = False
        self._last_mpc_cmd = None
        self._last_backup_cmd = None
        self._last_tracking_error = None
        self._last_consistency = None
        self._last_mpc_health = None
        # v3.17.3: 重置 horizon 到正常值
        self._current_horizon = self.horizon_normal
        if self.mpc_tracker:
            self.mpc_tracker.set_horizon(self.horizon_normal)
    
    def shutdown(self) -> None:
        """清理资源"""
        if self.backup_tracker: self.backup_tracker.shutdown()
        if self.mpc_tracker: self.mpc_tracker.shutdown()
```
