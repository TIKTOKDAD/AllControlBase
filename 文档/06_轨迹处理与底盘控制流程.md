# 网络输出轨迹到 TurtleBot 底盘控制命令的处理流程

## 概述

本文档详细说明了系统如何将网络输出的 8 个轨迹点转换为 TurtleBot 底盘可执行的速度命令 (vx, omega)。

## 1. 数据流总览

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                              完整数据流                                      │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  网络输出 (8个点)          坐标变换              控制器计算         底盘命令  │
│  ┌─────────────┐      ┌─────────────┐      ┌─────────────┐    ┌─────────┐  │
│  │ Trajectory  │ ──→  │ Transform   │ ──→  │ MPC/Pure    │ ─→ │ vx, ω   │  │
│  │ (base_link) │      │ (→ odom)    │      │ Pursuit     │    │         │  │
│  └─────────────┘      └─────────────┘      └─────────────┘    └─────────┘  │
│                                                                             │
│  局部坐标系               世界坐标系            轨迹跟踪          机体坐标系  │
│  (相对于机器人)           (里程计坐标系)        (计算控制量)       (速度命令)  │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

## 2. 坐标系说明

### 2.1 base_link (机体坐标系)
- **原点**: 机器人中心
- **X轴**: 朝前
- **Y轴**: 朝左
- **Z轴**: 朝上
- **特点**: 随机器人移动和旋转，网络输出的轨迹在此坐标系下

### 2.2 odom (里程计坐标系)
- **原点**: 机器人启动位置
- **特点**: 固定不动（相对于启动位置），会有漂移但不需要建图/定位
- **用途**: 控制器在此坐标系下工作

```
    base_link (机体坐标系)              odom (里程计坐标系)
    ┌───────────────┐                   ┌─────────────────────┐
    │       ↑ X     │                   │                     │
    │       │       │    坐标变换        │    机器人轨迹       │
    │    ←──┼──→    │  ───────────→     │    ○──○──○──○       │
    │     Y │       │  base_link→odom   │                     │
    │       ↓       │                   │    启动位置 ●       │
    └───────────────┘                   └─────────────────────┘
```

## 3. 详细处理步骤

### 3.1 网络输出轨迹 (Trajectory)

网络输出的轨迹数据结构：

```python
@dataclass
class Trajectory:
    header: Header              # 时间戳和坐标系 (frame_id='base_link')
    points: List[Point3D]       # 8个轨迹点 [(x1,y1,z1), (x2,y2,z2), ...]
    velocities: np.ndarray      # 可选的速度数组 [N, 4]: [vx, vy, vz, wz]
    dt_sec: float               # 时间步长 (默认 0.1s)
    confidence: float           # 网络置信度 [0, 1]
    mode: TrajectoryMode        # 轨迹模式
    soft_enabled: bool          # Soft Head 是否启用
```

**关键点**:
- 8个点是相对于当前机器人位置的局部坐标
- 第一个点通常接近 (0, 0, 0)，表示当前位置
- 后续点表示未来 0.1s, 0.2s, ... 0.7s 的期望位置

### 3.2 坐标变换 (RobustCoordinateTransformer)

将局部轨迹变换到世界坐标系：

```python
def transform_trajectory(self, traj: Trajectory, target_frame: str, 
                        target_time: float) -> Tuple[Trajectory, TransformStatus]:
    # 1. 获取 TF2 变换 (base_link → odom)
    position, yaw, success = self._try_tf2_lookup(target_frame, source_frame, lookup_time)
    
    # 2. 应用变换到每个轨迹点
    for p in traj.points:
        # 旋转 + 平移: p_odom = R(yaw) @ p_local + position
        new_x = p.x * cos(yaw) - p.y * sin(yaw) + position[0]
        new_y = p.x * sin(yaw) + p.y * cos(yaw) + position[1]
```

**变换公式**:
```
p_odom = R(yaw) × p_local + t

其中:
- R(yaw) = [cos(yaw), -sin(yaw)]  旋转矩阵
          [sin(yaw),  cos(yaw)]
- t = [tx, ty]  机器人在 odom 坐标系中的位置
```

### 3.3 状态估计 (AdaptiveEKFEstimator)

获取机器人当前状态：

```python
state = [px, py, pz, vx, vy, vz, theta, omega]
#        位置        速度          航向   角速度
```

状态来源：
- 里程计 (Odometry): 提供位置和速度
- IMU (可选): 提供角速度和加速度，用于提高估计精度

### 3.4 轨迹跟踪控制器

系统提供两种控制器：

#### 3.4.1 MPC 控制器 (主控制器)

```python
class MPCController:
    def compute(self, state, trajectory, consistency) -> ControlOutput:
        # 1. 设置初始状态约束
        self._solver.set(0, 'lbx', state)
        self._solver.set(0, 'ubx', state)
        
        # 2. 设置参考轨迹
        for i in range(self.horizon):
            ref_point = trajectory.points[i]
            y_ref = [ref_point.x, ref_point.y, ref_point.z, vx_ref, vy_ref, ...]
            self._solver.set(i, 'yref', y_ref)
        
        # 3. 求解优化问题
        status = self._solver.solve()
        
        # 4. 提取控制输出
        u_opt = self._solver.get(0, 'u')  # [ax, ay, az, alpha]
        x_next = self._solver.get(1, 'x')  # 下一时刻状态
        
        # 5. 对于差速车，转换为 (vx, omega)
        v_world = sqrt(x_next[3]**2 + x_next[4]**2)
        vx = v_world
        omega = x_next[7]
```

**MPC 优化目标**:
- 最小化位置跟踪误差
- 最小化速度跟踪误差
- 最小化航向误差
- 最小化控制输入变化

#### 3.4.2 Pure Pursuit 控制器 (备用控制器)

```python
class PurePursuitController:
    def compute(self, state, trajectory, consistency) -> ControlOutput:
        # 1. 计算前视距离
        lookahead = self.lookahead_dist + self.lookahead_ratio * current_v
        
        # 2. 找到前视点
        lookahead_point = self._find_lookahead_point(trajectory.points, px, py, lookahead)
        
        # 3. 计算到前视点的方向
        dx = lookahead_point.x - px
        dy = lookahead_point.y - py
        
        # 4. 转换到机体坐标系
        local_x = dx * cos(theta) + dy * sin(theta)
        local_y = -dx * sin(theta) + dy * cos(theta)
        
        # 5. 计算曲率 (Pure Pursuit 核心公式)
        L_sq = local_x**2 + local_y**2
        curvature = 2.0 * local_y / L_sq
        
        # 6. 计算角速度
        omega = target_v * curvature
        
        return ControlOutput(vx=target_v, omega=omega)
```

**Pure Pursuit 公式**:
```
曲率 κ = 2 * y_local / L²

其中:
- y_local: 前视点在机体坐标系中的 y 坐标
- L: 到前视点的距离

角速度 ω = v * κ
```

### 3.5 速度平滑 (VelocitySmoother)

防止速度突变：

```python
class VelocitySmoother:
    def smooth(self, cmd, last_cmd) -> ControlOutput:
        # 限制加速度
        dvx = cmd.vx - last_cmd.vx
        dvy = cmd.vy - last_cmd.vy
        dv_magnitude = sqrt(dvx**2 + dvy**2)
        
        if dv_magnitude > self.max_dv:
            scale = self.max_dv / dv_magnitude
            dvx *= scale
            dvy *= scale
        
        # 限制角加速度
        smoothed_omega = clip(cmd.omega, 
                             last_cmd.omega - max_domega,
                             last_cmd.omega + max_domega)
```

### 3.6 最终输出 (ControlOutput)

```python
@dataclass
class ControlOutput:
    vx: float      # 前进速度 (m/s)
    vy: float      # 侧向速度 (差速车为 0)
    vz: float      # 垂直速度 (地面机器人为 0)
    omega: float   # 角速度 (rad/s)
    frame_id: str  # 输出坐标系 ('base_link')
```

对于 TurtleBot (差速车):
- `vx`: 前进速度，正值前进，负值后退
- `omega`: 角速度，正值左转，负值右转
- `vy`, `vz`: 始终为 0

## 4. 完整处理流程示例

假设网络输出 8 个点（局部坐标系）：
```
点0: (0.0, 0.0, 0)     # 当前位置
点1: (0.1, 0.02, 0)    # 0.1s 后
点2: (0.2, 0.05, 0)    # 0.2s 后
点3: (0.3, 0.08, 0)    # 0.3s 后
...
点7: (0.7, 0.2, 0)     # 0.7s 后
```

机器人当前状态（odom 坐标系）：
```
位置: (5.0, 3.0, 0)
航向: 0.5 rad (约 28.6°)
速度: 0.3 m/s
```

### 步骤 1: 坐标变换
```python
# 变换第一个点
cos_yaw = cos(0.5) = 0.877
sin_yaw = sin(0.5) = 0.479

# 点1 变换: (0.1, 0.02) → odom
new_x = 0.1 * 0.877 - 0.02 * 0.479 + 5.0 = 5.078
new_y = 0.1 * 0.479 + 0.02 * 0.877 + 3.0 = 3.065
```

### 步骤 2: Pure Pursuit 计算
```python
# 假设前视点为点3 (变换后)
lookahead_point = (5.234, 3.195)

# 计算方向
dx = 5.234 - 5.0 = 0.234
dy = 3.195 - 3.0 = 0.195

# 转换到机体坐标系
local_x = 0.234 * 0.877 + 0.195 * 0.479 = 0.298
local_y = -0.234 * 0.479 + 0.195 * 0.877 = 0.059

# 计算曲率
L_sq = 0.298² + 0.059² = 0.092
curvature = 2 * 0.059 / 0.092 = 1.28

# 计算角速度 (假设目标速度 0.3 m/s)
omega = 0.3 * 1.28 = 0.384 rad/s
```

### 步骤 3: 速度平滑
```python
# 假设上一次命令: vx=0.28, omega=0.35
# 新命令: vx=0.30, omega=0.384

# 检查加速度限制 (假设 max_dv = 0.03)
dvx = 0.30 - 0.28 = 0.02  # OK
domega = 0.384 - 0.35 = 0.034  # 需要限制

# 平滑后
smoothed_vx = 0.30
smoothed_omega = 0.35 + 0.03 = 0.38  # 限制到 max_domega
```

### 步骤 4: 最终输出
```python
ControlOutput(
    vx=0.30,      # 前进 0.3 m/s
    vy=0.0,       # 差速车无侧向速度
    vz=0.0,       # 地面机器人
    omega=0.38,   # 左转 0.38 rad/s
    frame_id='base_link'
)
```

## 5. 关键参数配置

```yaml
# 控制器参数
mpc:
  horizon: 20           # 预测时域
  dt: 0.02              # 控制周期 (50Hz)
  weights:
    position: 10.0      # 位置跟踪权重
    velocity: 1.0       # 速度跟踪权重
    heading: 5.0        # 航向跟踪权重

backup:
  lookahead_dist: 1.0   # 基础前视距离
  lookahead_ratio: 0.5  # 速度相关前视距离系数
  kp_heading: 1.5       # 航向控制增益

constraints:
  v_max: 0.5            # 最大速度 (m/s)
  omega_max: 1.0        # 最大角速度 (rad/s)
  a_max: 1.5            # 最大加速度 (m/s²)
  alpha_max: 3.0        # 最大角加速度 (rad/s²)

trajectory:
  default_dt_sec: 0.1   # 轨迹点时间间隔
```

## 6. 特殊情况处理

### 6.1 目标点在后方
当目标点在机器人后方时，Pure Pursuit 会：
1. 检测 `local_x < 0`
2. 切换到航向误差控制模式
3. 先原地旋转对准目标方向
4. 再前进

### 6.2 TF2 不可用
当 TF2 坐标变换不可用时：
1. 降级到 odom 积分估计
2. 记录降级持续时间
3. 超过 1000ms 触发 MPC_DEGRADED 状态
4. TF2 恢复时进行漂移校正

### 6.3 MPC 求解失败
当 MPC 求解失败时：
1. 自动切换到 Pure Pursuit 备用控制器
2. 使用平滑过渡避免控制跳变
3. MPC 恢复后再切换回来

## 7. 总结

```
网络输出 8 点轨迹 (base_link)
        ↓
    坐标变换 (TF2)
        ↓
轨迹点转换到 odom 坐标系
        ↓
    状态估计 (EKF)
        ↓
获取机器人当前位置/速度/航向
        ↓
    轨迹跟踪 (MPC/Pure Pursuit)
        ↓
计算期望速度和角速度
        ↓
    速度平滑
        ↓
限制加速度，防止突变
        ↓
输出 (vx, omega) 到 TurtleBot
```

核心算法：
- **MPC**: 优化未来轨迹，考虑动力学约束
- **Pure Pursuit**: 几何方法，计算曲率跟踪前视点
- **速度平滑**: 限制加速度，确保平滑运动
