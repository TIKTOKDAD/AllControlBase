# unified_diagnostics.py 未诊断参数分析

## 🔍 影响轨迹跟踪但未被诊断的参数

基于对 `unified_diagnostics.py` 和 `universal_controller` 的分析，以下参数会显著影响轨迹跟踪性能，但**未被当前诊断工具覆盖**：

---

## 1. MPC 权重参数 ⚠️ **关键但未诊断**

### 未诊断的参数：
```yaml
mpc:
  weights:
    position: 10.0      # 位置跟踪权重
    velocity: 1.0       # 速度跟踪权重
    heading: 5.0        # 航向跟踪权重
    control_accel: 0.2  # 加速度平滑权重
    control_alpha: 0.2  # 角加速度平滑权重
```

### 影响：
- **position 权重过高**：会导致激进跟踪，牺牲平滑性
- **velocity 权重过低**：速度跟踪不准确，可能导致超速或欠速
- **heading 权重不当**：转弯时航向误差大
- **control_accel/alpha 过低**：控制输出抖动，不平滑

### 为什么未诊断：
- `unified_diagnostics.py` 只检查 MPC 求解时间和成功率
- **没有分析权重对跟踪误差的影响**
- 没有提供权重调优建议

### 建议诊断方法：
```python
# 应该添加的诊断逻辑
def _analyze_mpc_weights(self, diagnostics_data):
    """分析 MPC 权重是否合理"""
    lateral_errors = [d['lateral_error'] for d in diagnostics_data]
    heading_errors = [d['heading_error'] for d in diagnostics_data]
    control_smoothness = self._compute_control_smoothness(diagnostics_data)
    
    # 如果横向误差大但控制平滑，说明 position 权重过低
    if np.mean(lateral_errors) > 0.2 and control_smoothness < 0.1:
        print("建议: 增加 mpc.weights.position (当前可能过低)")
    
    # 如果控制抖动大，说明 control_accel 权重过低
    if control_smoothness > 0.5:
        print("建议: 增加 mpc.weights.control_accel 和 control_alpha")
```

---

## 2. 一致性检查参数 ⚠️ **部分诊断**

### 未充分诊断的参数：
```yaml
consistency:
  kappa_thresh: 0.5              # 曲率一致性阈值
  v_dir_thresh: 0.8              # 速度方向一致性阈值
  temporal_smooth_thresh: 0.4    # 时间平滑性阈值 (已诊断但不够)
  alpha_min: 0.1                 # 最小一致性分数
  max_curvature: 10.0            # 最大允许曲率
  temporal_window_size: 10       # 时间窗口大小
  weights:
    kappa: 0.3                   # 曲率权重
    velocity: 0.3                # 速度权重
    temporal: 0.4                # 时间权重
```

### 影响：
- **kappa_thresh 过严**：会频繁拒绝合理轨迹，导致降级到备用控制器
- **temporal_window_size 过小**：对轨迹抖动敏感
- **weights 不平衡**：可能过度关注某一方面而忽略其他

### 当前诊断的不足：
- 只调整了 `temporal_smooth_thresh` (从 0.3 → 0.4)
- **没有分析一致性检查的拒绝率**
- 没有建议其他阈值的调整

### 建议诊断方法：
```python
def _analyze_consistency_rejections(self, diagnostics_data):
    """分析一致性检查拒绝率"""
    alpha_values = [d.get('alpha', 1.0) for d in diagnostics_data]
    rejection_rate = sum(1 for a in alpha_values if a < 0.5) / len(alpha_values)
    
    if rejection_rate > 0.1:  # 超过10%拒绝率
        print(f"警告: 一致性检查拒绝率 {rejection_rate*100:.1f}%")
        print("建议: 放宽 consistency.kappa_thresh 或 v_dir_thresh")
        
        # 分析是哪个维度导致拒绝
        # (需要从 diagnostics 消息中获取更详细的一致性分数)
```

---

## 3. 备用控制器参数 ⚠️ **未诊断**

### 未诊断的参数：
```yaml
backup:
  lookahead_dist: 0.3            # 前瞻距离
  min_lookahead: 0.18            # 最小前瞻
  max_lookahead: 0.9             # 最大前瞻
  lookahead_ratio: 0.5           # 前瞻比例
  kp_z: 1.0                      # 横向控制增益
  kp_heading: 1.5                # 航向控制增益
  heading_mode: follow_velocity  # 航向模式
  max_curvature: 5.0             # 最大曲率
  min_turn_speed: 0.1            # 最小转弯速度
  default_speed_ratio: 0.5       # 默认速度比例
```

### 影响：
- **lookahead_dist 不当**：影响转弯预判和平滑性
- **kp_z / kp_heading 过高**：导致震荡
- **kp_z / kp_heading 过低**：跟踪误差大

### 为什么未诊断：
- 诊断显示 "备用控制器使用率 0%"，就认为没问题
- **但没有测试备用控制器的性能**
- 如果 MPC 偶尔失败，备用控制器性能差会导致严重问题

### 建议诊断方法：
```python
def _test_backup_controller(self):
    """主动测试备用控制器性能"""
    print("\n测试备用控制器 (强制禁用 MPC 10秒)...")
    
    # 发布服务调用，临时禁用 MPC
    # 观察备用控制器的跟踪误差
    
    # 分析结果并给出调优建议
```

---

## 4. 过渡控制参数 ⚠️ **未诊断**

### 未诊断的参数：
```yaml
transition:
  type: exponential              # 过渡类型
  tau: 0.05                      # 时间常数
  max_duration: 0.5              # 最大过渡时间
  completion_threshold: 0.95     # 完成阈值
  duration: 0.2                  # 过渡持续时间
```

### 影响：
- **tau 过小**：过渡太快，可能导致抖动
- **tau 过大**：过渡太慢，响应迟钝
- **completion_threshold 不当**：影响模式切换时机

### 为什么未诊断：
- 诊断工具没有检测模式切换事件
- 没有分析过渡过程的平滑性

---

## 5. 跟踪评分参数 ⚠️ **未诊断**

### 未诊断的参数：
```yaml
tracking:
  lateral_thresh: 0.30           # 横向误差阈值 (已诊断)
  longitudinal_thresh: 0.50      # 纵向误差阈值 (未诊断)
  heading_thresh: 0.50           # 航向误差阈值 (部分诊断)
  prediction_thresh: 0.50        # 预测误差阈值 (未诊断)
  weights:
    lateral: 0.4                 # 横向权重
    longitudinal: 0.4            # 纵向权重
    heading: 0.2                 # 航向权重
  rating:
    excellent: 90                # 优秀评分阈值
    good: 70                     # 良好评分阈值
    fair: 50                     # 一般评分阈值
```

### 影响：
- **longitudinal_thresh 不当**：纵向跟踪误差大但未被发现
- **prediction_thresh 不当**：预测精度差但未被发现
- **weights 不平衡**：评分不能真实反映跟踪质量

### 当前诊断的不足：
- 只检查了横向误差 (lateral_thresh)
- **没有检查纵向误差和预测误差**
- 没有分析跟踪评分的分布

### 建议诊断方法：
```python
def _analyze_tracking_quality(self, diagnostics_data):
    """全面分析跟踪质量"""
    lateral_errors = [d['lateral_error'] for d in diagnostics_data]
    # 需要从 diagnostics 中获取纵向误差和预测误差
    # longitudinal_errors = [d.get('longitudinal_error', 0) for d in diagnostics_data]
    # prediction_errors = [d.get('prediction_error', 0) for d in diagnostics_data]
    
    print(f"横向误差: avg={np.mean(lateral_errors):.3f}m, max={np.max(lateral_errors):.3f}m")
    # print(f"纵向误差: avg={np.mean(longitudinal_errors):.3f}m")
    # print(f"预测误差: avg={np.mean(prediction_errors):.3f}m")
    
    # 给出阈值调整建议
```

---

## 6. 状态机参数 ⚠️ **未诊断**

### 未诊断的参数：
```yaml
safety:
  state_machine:
    alpha_disable_thresh: 0.0          # Alpha 禁用阈值
    alpha_recovery_value: 0.0          # Alpha 恢复值
    alpha_recovery_thresh: 5           # Alpha 恢复次数阈值
    mpc_recovery_thresh: 5             # MPC 恢复次数阈值
    mpc_fail_window_size: 10           # MPC 失败窗口大小
    mpc_fail_thresh: 3                 # MPC 失败次数阈值
    mpc_fail_ratio_thresh: 0.5         # MPC 失败比例阈值
    mpc_recovery_history_min: 3        # MPC 恢复历史最小值
    mpc_recovery_recent_count: 5       # MPC 恢复最近计数
    mpc_recovery_tolerance: 0          # MPC 恢复容忍度
    mpc_recovery_success_ratio: 0.8    # MPC 恢复成功率
```

### 影响：
- **mpc_fail_thresh 过低**：频繁降级到备用控制器
- **mpc_recovery_thresh 过高**：恢复到 MPC 太慢
- **alpha_recovery_thresh 不当**：一致性检查恢复不及时

### 为什么未诊断：
- 诊断工具只看 MPC 成功率，不看状态机切换频率
- **没有分析控制器状态切换历史**

---

## 7. 速度限制参数 ⚠️ **部分诊断**

### 未充分诊断的参数：
```yaml
constraints:
  v_low_thresh: 0.10             # 低速阈值 (未诊断)
  omega_max_low: 0.80            # 低速时最大角速度 (未诊断)

safety:
  low_speed:
    threshold: 0.10              # 低速阈值 (未诊断)
    omega_limit: 1.00            # 低速角速度限制 (未诊断)
```

### 影响：
- **v_low_thresh 不当**：低速/高速切换不平滑
- **omega_max_low 过低**：低速时转弯能力受限

### 当前诊断的不足：
- 只诊断了 `v_max`, `omega_max`, `a_max`
- **没有诊断低速相关参数**

---

## 8. 加速度滤波参数 ⚠️ **未诊断**

### 未诊断的参数：
```yaml
safety:
  accel_filter_window: 3             # 加速度滤波窗口
  accel_filter_alpha: 0.3            # 滤波系数
  accel_filter_warmup_alpha: 0.5     # 预热滤波系数
  accel_filter_warmup_period: 3      # 预热周期
  min_dt_for_accel: 0.001            # 最小时间间隔
  max_dt_for_accel: 1.0              # 最大时间间隔
```

### 影响：
- **accel_filter_alpha 过小**：加速度估计滞后
- **accel_filter_alpha 过大**：加速度估计噪声大
- **filter_window 不当**：影响加速度约束检查

### 为什么未诊断：
- 诊断工具没有分析加速度估计质量
- 没有检查加速度滤波效果

---

## 9. TF 变换参数 ⚠️ **未诊断**

### 未诊断的参数：
```yaml
transform:
  timeout_ms: 50                     # TF 超时
  fallback_duration_limit_ms: 500    # 回退持续时间限制
  fallback_critical_limit_ms: 1000   # 回退临界限制
  drift_estimation_enabled: false    # 漂移估计
  recovery_correction_enabled: true  # 恢复校正
  drift_rate: 0.01                   # 漂移率
  drift_velocity_factor: 0.1         # 漂移速度因子
  max_drift_dt: 0.5                  # 最大漂移时间
  drift_correction_thresh: 0.01      # 漂移校正阈值
```

### 影响：
- **timeout_ms 过小**：频繁 TF 超时
- **drift_estimation_enabled=false**：长时间运行可能累积漂移
- **recovery_correction 参数不当**：TF 恢复后位置跳变

### 为什么未诊断：
- 诊断工具没有检查 TF 变换质量
- 没有分析 TF 超时频率

---

## 10. EKF 参数 ⚠️ **部分诊断**

### 未充分诊断的参数：
```yaml
ekf:
  use_odom_orientation_fallback: true    # 使用里程计姿态回退
  imu_motion_compensation: false         # IMU 运动补偿 (未诊断)
  process_noise:                         # 过程噪声 (已调整)
    position: 0.0026
    velocity: 0.0130
    orientation: 0.0105
    angular_velocity: 0.1                # 角速度噪声 (未诊断)
  measurement_noise:                     # 测量噪声 (已调整)
    odom_position: 0.0026
    odom_velocity: 0.0130
```

### 影响：
- **imu_motion_compensation=false**：快速运动时姿态估计差
- **angular_velocity 噪声不当**：角速度估计不准确

### 当前诊断的不足：
- 只根据里程计抖动调整了 position/velocity 噪声
- **没有诊断 IMU 相关参数**
- 没有分析 EKF 估计质量

---

## 📋 建议增强的诊断功能

### 1. 添加 MPC 权重分析
```python
def _analyze_mpc_weights_impact(self, diagnostics_data):
    """分析 MPC 权重对跟踪性能的影响"""
    # 计算跟踪误差与控制平滑性的权衡
    # 给出权重调整建议
```

### 2. 添加一致性检查分析
```python
def _analyze_consistency_check_performance(self, diagnostics_data):
    """分析一致性检查的拒绝率和影响"""
    # 统计 alpha < 0.5 的频率
    # 分析是哪个维度导致拒绝
    # 给出阈值调整建议
```

### 3. 添加备用控制器测试
```python
def _test_backup_controller_performance(self):
    """主动测试备用控制器性能"""
    # 临时禁用 MPC
    # 测试备用控制器跟踪误差
    # 给出参数调优建议
```

### 4. 添加状态机切换分析
```python
def _analyze_state_machine_transitions(self, diagnostics_data):
    """分析控制器状态切换频率"""
    # 统计 MPC <-> Backup 切换次数
    # 分析切换原因
    # 给出状态机参数建议
```

### 5. 添加纵向跟踪分析
```python
def _analyze_longitudinal_tracking(self, diagnostics_data):
    """分析纵向跟踪误差"""
    # 需要从 diagnostics 消息中获取纵向误差
    # 给出 longitudinal_thresh 调整建议
```

---

## 🎯 优先级排序

### 高优先级（严重影响跟踪性能）：
1. ⭐⭐⭐ **MPC 权重参数** - 直接影响跟踪精度和平滑性
2. ⭐⭐⭐ **一致性检查参数** - 影响轨迹接受率
3. ⭐⭐ **备用控制器参数** - MPC 失败时的保底性能

### 中优先级（间接影响）：
4. ⭐⭐ **状态机参数** - 影响控制器切换频率
5. ⭐⭐ **跟踪评分参数** - 影响性能评估准确性
6. ⭐ **过渡控制参数** - 影响模式切换平滑性

### 低优先级（边缘情况）：
7. ⭐ **加速度滤波参数** - 影响加速度估计
8. ⭐ **TF 变换参数** - 影响坐标变换
9. ⭐ **低速参数** - 影响低速行为

---

## 💡 实施建议

### 短期（立即可做）：
1. 手动检查 MPC 权重是否合理
2. 观察 `/controller/diagnostics` 中的 `alpha` 值，判断一致性检查是否过严
3. 检查日志中是否有频繁的状态切换

### 中期（需要代码修改）：
1. 在 `unified_diagnostics.py` 中添加 MPC 权重分析
2. 添加一致性检查拒绝率统计
3. 添加状态机切换频率分析

### 长期（完整增强）：
1. 实现备用控制器主动测试
2. 添加纵向跟踪误差分析
3. 实现 TF 变换质量监控

---

## 📝 总结

`unified_diagnostics.py` 当前主要关注：
- ✅ 传感器频率和延迟
- ✅ 底盘能力测试
- ✅ MPC 求解时间和成功率
- ✅ 横向跟踪误差

**但遗漏了**：
- ❌ MPC 权重调优
- ❌ 一致性检查性能
- ❌ 备用控制器性能
- ❌ 状态机切换分析
- ❌ 纵向跟踪误差
- ❌ 控制平滑性分析
- ❌ TF 变换质量
- ❌ EKF 估计质量

这些遗漏的参数可能导致：
1. 跟踪精度不佳但不知道原因
2. 控制输出抖动但未被发现
3. 一致性检查过严导致频繁降级
4. 备用控制器性能差但未被测试

**建议优先增强 MPC 权重分析和一致性检查分析。**
